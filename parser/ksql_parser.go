// Code generated from KSql.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // KSql

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 175, 1131,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 3, 2, 7, 2, 124, 10, 2, 12, 2, 14, 2, 127, 11, 2, 3,
	2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 138, 10, 3, 3,
	3, 5, 3, 141, 10, 3, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 5, 6, 154, 10, 6, 3, 6, 3, 6, 5, 6, 158, 10, 6, 3, 6, 3,
	6, 3, 6, 5, 6, 163, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 168, 10, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 5, 6, 174, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 187, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 192,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 203,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 209, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 231, 10, 6, 3, 6, 5, 6, 234, 10, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 5, 6, 240, 10, 6, 3, 6, 3, 6, 5, 6, 244, 10, 6, 3, 6,
	3, 6, 5, 6, 248, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 253, 10, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 5, 6, 259, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 264, 10, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 272, 10, 6, 3, 6, 5, 6, 275, 10, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 281, 10, 6, 3, 6, 3, 6, 5, 6, 285, 10, 6,
	3, 6, 3, 6, 5, 6, 289, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 294, 10, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 5, 6, 300, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 305, 10, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 316, 10, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 327, 10, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 335, 10, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 344, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 349,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 355, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	360, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 366, 10, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 5, 6, 372, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 379, 10, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 389, 10, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 398, 10, 6, 12, 6, 14, 6, 401,
	11, 6, 5, 6, 403, 10, 6, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 409, 10, 7, 3, 7,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 419, 10, 7, 3, 7, 3, 7,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 428, 10, 7, 3, 7, 3, 7, 5, 7, 432,
	10, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 438, 10, 7, 3, 7, 3, 7, 5, 7, 442,
	10, 7, 5, 7, 444, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9,
	7, 9, 454, 10, 9, 12, 9, 14, 9, 457, 11, 9, 3, 9, 3, 9, 3, 9, 3, 9, 5,
	9, 463, 10, 9, 3, 9, 3, 9, 5, 9, 467, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 472,
	10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 477, 10, 9, 3, 9, 3, 9, 5, 9, 481, 10, 9,
	3, 9, 3, 9, 5, 9, 485, 10, 9, 3, 9, 5, 9, 488, 10, 9, 3, 10, 3, 10, 3,
	11, 3, 11, 5, 11, 494, 10, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12,
	3, 12, 7, 12, 503, 10, 12, 12, 12, 14, 12, 506, 11, 12, 3, 12, 3, 12, 3,
	13, 3, 13, 3, 13, 5, 13, 513, 10, 13, 3, 13, 5, 13, 516, 10, 13, 3, 14,
	3, 14, 3, 14, 3, 14, 7, 14, 522, 10, 14, 12, 14, 14, 14, 525, 11, 14, 3,
	14, 3, 14, 3, 15, 3, 15, 5, 15, 531, 10, 15, 3, 15, 3, 15, 3, 15, 3, 16,
	3, 16, 5, 16, 538, 10, 16, 3, 16, 5, 16, 541, 10, 16, 3, 16, 5, 16, 544,
	10, 16, 3, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 21, 5, 21, 562, 10, 21, 3,
	21, 3, 21, 3, 21, 5, 21, 567, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 5, 22, 576, 10, 22, 3, 22, 3, 22, 5, 22, 580, 10, 22, 3,
	22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 5, 23, 596, 10, 23, 3, 23, 3, 23, 5, 23, 600, 10,
	23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 610,
	10, 24, 3, 24, 3, 24, 5, 24, 614, 10, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3,
	26, 3, 26, 3, 26, 7, 26, 623, 10, 26, 12, 26, 14, 26, 626, 11, 26, 3, 26,
	3, 26, 3, 26, 3, 26, 7, 26, 632, 10, 26, 12, 26, 14, 26, 635, 11, 26, 5,
	26, 637, 10, 26, 3, 26, 5, 26, 640, 10, 26, 3, 27, 3, 27, 3, 27, 7, 27,
	645, 10, 27, 12, 27, 14, 27, 648, 11, 27, 3, 27, 3, 27, 3, 27, 3, 27, 7,
	27, 654, 10, 27, 12, 27, 14, 27, 657, 11, 27, 5, 27, 659, 10, 27, 3, 27,
	5, 27, 662, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 668, 10, 28, 12,
	28, 14, 28, 671, 11, 28, 5, 28, 673, 10, 28, 3, 28, 3, 28, 3, 29, 3, 29,
	5, 29, 679, 10, 29, 3, 29, 5, 29, 682, 10, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 5, 29, 689, 10, 29, 3, 30, 3, 30, 6, 30, 693, 10, 30, 13, 30,
	14, 30, 694, 3, 30, 5, 30, 698, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 5,
	31, 704, 10, 31, 3, 31, 3, 31, 3, 32, 5, 32, 709, 10, 32, 3, 32, 3, 32,
	5, 32, 713, 10, 32, 3, 32, 3, 32, 5, 32, 717, 10, 32, 5, 32, 719, 10, 32,
	3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 730,
	10, 34, 3, 34, 3, 34, 5, 34, 734, 10, 34, 5, 34, 736, 10, 34, 3, 35, 3,
	35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 5, 37, 746, 10, 37, 3, 37,
	5, 37, 749, 10, 37, 3, 38, 3, 38, 3, 38, 3, 38, 7, 38, 755, 10, 38, 12,
	38, 14, 38, 758, 11, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 40, 3, 40, 3, 41,
	3, 41, 3, 41, 3, 41, 5, 41, 770, 10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	41, 3, 41, 7, 41, 778, 10, 41, 12, 41, 14, 41, 781, 11, 41, 3, 42, 3, 42,
	5, 42, 785, 10, 42, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 791, 10, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 799, 10, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 7, 43, 806, 10, 43, 12, 43, 14, 43, 809, 11, 43, 3,
	43, 3, 43, 3, 43, 5, 43, 814, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43,
	820, 10, 43, 3, 43, 3, 43, 5, 43, 824, 10, 43, 3, 43, 3, 43, 3, 43, 5,
	43, 829, 10, 43, 3, 43, 3, 43, 3, 43, 5, 43, 834, 10, 43, 3, 44, 3, 44,
	3, 44, 3, 44, 5, 44, 840, 10, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3,
	44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44, 854, 10, 44, 12, 44,
	14, 44, 857, 11, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 6, 45, 867, 10, 45, 13, 45, 14, 45, 868, 3, 45, 3, 45, 5, 45, 873,
	10, 45, 3, 45, 3, 45, 3, 45, 3, 45, 6, 45, 879, 10, 45, 13, 45, 14, 45,
	880, 3, 45, 3, 45, 5, 45, 885, 10, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 901,
	10, 45, 12, 45, 14, 45, 904, 11, 45, 5, 45, 906, 10, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 919,
	10, 45, 12, 45, 14, 45, 922, 11, 45, 5, 45, 924, 10, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 937,
	10, 45, 12, 45, 14, 45, 940, 11, 45, 5, 45, 942, 10, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 955,
	10, 45, 12, 45, 14, 45, 958, 11, 45, 3, 45, 3, 45, 7, 45, 962, 10, 45,
	12, 45, 14, 45, 965, 11, 45, 5, 45, 967, 10, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 980, 10, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 990, 10,
	45, 12, 45, 14, 45, 993, 11, 45, 3, 46, 3, 46, 5, 46, 997, 10, 46, 3, 47,
	3, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 7, 50, 1028, 10, 50, 12,
	50, 14, 50, 1031, 11, 50, 5, 50, 1033, 10, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 7, 50,
	1048, 10, 50, 12, 50, 14, 50, 1051, 11, 50, 3, 50, 3, 50, 5, 50, 1055,
	10, 50, 5, 50, 1057, 10, 50, 3, 50, 3, 50, 7, 50, 1061, 10, 50, 12, 50,
	14, 50, 1064, 11, 50, 3, 51, 3, 51, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 1081, 10,
	54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55, 1091,
	10, 55, 12, 55, 14, 55, 1094, 11, 55, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55,
	1100, 10, 55, 3, 56, 3, 56, 3, 57, 3, 57, 3, 58, 3, 58, 3, 59, 5, 59, 1109,
	10, 59, 3, 59, 3, 59, 5, 59, 1113, 10, 59, 3, 59, 3, 59, 5, 59, 1117, 10,
	59, 3, 59, 5, 59, 1120, 10, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60,
	1127, 10, 60, 3, 61, 3, 61, 3, 61, 2, 6, 80, 86, 88, 98, 62, 2, 4, 6, 8,
	10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
	46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
	82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 2, 14, 3, 2, 98, 99, 3, 2, 133, 134, 4, 2, 83, 83,
	85, 85, 3, 2, 12, 13, 4, 2, 43, 43, 121, 121, 4, 2, 46, 50, 53, 57, 3,
	2, 152, 153, 3, 2, 154, 156, 3, 2, 146, 151, 3, 2, 37, 38, 4, 2, 10, 10,
	162, 162, 17, 2, 10, 13, 34, 34, 39, 49, 58, 58, 78, 79, 93, 96, 98, 98,
	100, 100, 106, 110, 114, 116, 119, 120, 130, 130, 133, 134, 138, 142, 145,
	145, 2, 1283, 2, 125, 3, 2, 2, 2, 4, 137, 3, 2, 2, 2, 6, 142, 3, 2, 2,
	2, 8, 145, 3, 2, 2, 2, 10, 402, 3, 2, 2, 2, 12, 443, 3, 2, 2, 2, 14, 445,
	3, 2, 2, 2, 16, 449, 3, 2, 2, 2, 18, 489, 3, 2, 2, 2, 20, 491, 3, 2, 2,
	2, 22, 498, 3, 2, 2, 2, 24, 509, 3, 2, 2, 2, 26, 517, 3, 2, 2, 2, 28, 530,
	3, 2, 2, 2, 30, 537, 3, 2, 2, 2, 32, 545, 3, 2, 2, 2, 34, 548, 3, 2, 2,
	2, 36, 551, 3, 2, 2, 2, 38, 555, 3, 2, 2, 2, 40, 561, 3, 2, 2, 2, 42, 568,
	3, 2, 2, 2, 44, 583, 3, 2, 2, 2, 46, 603, 3, 2, 2, 2, 48, 617, 3, 2, 2,
	2, 50, 639, 3, 2, 2, 2, 52, 661, 3, 2, 2, 2, 54, 663, 3, 2, 2, 2, 56, 688,
	3, 2, 2, 2, 58, 697, 3, 2, 2, 2, 60, 699, 3, 2, 2, 2, 62, 718, 3, 2, 2,
	2, 64, 720, 3, 2, 2, 2, 66, 735, 3, 2, 2, 2, 68, 737, 3, 2, 2, 2, 70, 740,
	3, 2, 2, 2, 72, 743, 3, 2, 2, 2, 74, 750, 3, 2, 2, 2, 76, 761, 3, 2, 2,
	2, 78, 763, 3, 2, 2, 2, 80, 769, 3, 2, 2, 2, 82, 782, 3, 2, 2, 2, 84, 833,
	3, 2, 2, 2, 86, 839, 3, 2, 2, 2, 88, 979, 3, 2, 2, 2, 90, 996, 3, 2, 2,
	2, 92, 998, 3, 2, 2, 2, 94, 1002, 3, 2, 2, 2, 96, 1004, 3, 2, 2, 2, 98,
	1056, 3, 2, 2, 2, 100, 1065, 3, 2, 2, 2, 102, 1067, 3, 2, 2, 2, 104, 1069,
	3, 2, 2, 2, 106, 1080, 3, 2, 2, 2, 108, 1099, 3, 2, 2, 2, 110, 1101, 3,
	2, 2, 2, 112, 1103, 3, 2, 2, 2, 114, 1105, 3, 2, 2, 2, 116, 1119, 3, 2,
	2, 2, 118, 1126, 3, 2, 2, 2, 120, 1128, 3, 2, 2, 2, 122, 124, 5, 6, 4,
	2, 123, 122, 3, 2, 2, 2, 124, 127, 3, 2, 2, 2, 125, 123, 3, 2, 2, 2, 125,
	126, 3, 2, 2, 2, 126, 128, 3, 2, 2, 2, 127, 125, 3, 2, 2, 2, 128, 129,
	7, 2, 2, 3, 129, 3, 3, 2, 2, 2, 130, 138, 5, 6, 4, 2, 131, 132, 5, 12,
	7, 2, 132, 133, 7, 3, 2, 2, 133, 138, 3, 2, 2, 2, 134, 135, 5, 14, 8, 2,
	135, 136, 7, 3, 2, 2, 136, 138, 3, 2, 2, 2, 137, 130, 3, 2, 2, 2, 137,
	131, 3, 2, 2, 2, 137, 134, 3, 2, 2, 2, 138, 140, 3, 2, 2, 2, 139, 141,
	7, 2, 2, 3, 140, 139, 3, 2, 2, 2, 140, 141, 3, 2, 2, 2, 141, 5, 3, 2, 2,
	2, 142, 143, 5, 10, 6, 2, 143, 144, 7, 3, 2, 2, 144, 7, 3, 2, 2, 2, 145,
	146, 5, 78, 40, 2, 146, 147, 7, 2, 2, 3, 147, 9, 3, 2, 2, 2, 148, 403,
	5, 16, 9, 2, 149, 150, 9, 2, 2, 2, 150, 403, 7, 124, 2, 2, 151, 153, 9,
	2, 2, 2, 152, 154, 7, 17, 2, 2, 153, 152, 3, 2, 2, 2, 153, 154, 3, 2, 2,
	2, 154, 155, 3, 2, 2, 2, 155, 157, 7, 101, 2, 2, 156, 158, 7, 91, 2, 2,
	157, 156, 3, 2, 2, 2, 157, 158, 3, 2, 2, 2, 158, 403, 3, 2, 2, 2, 159,
	160, 9, 2, 2, 2, 160, 162, 7, 86, 2, 2, 161, 163, 7, 91, 2, 2, 162, 161,
	3, 2, 2, 2, 162, 163, 3, 2, 2, 2, 163, 403, 3, 2, 2, 2, 164, 165, 9, 2,
	2, 2, 165, 167, 7, 100, 2, 2, 166, 168, 7, 91, 2, 2, 167, 166, 3, 2, 2,
	2, 167, 168, 3, 2, 2, 2, 168, 403, 3, 2, 2, 2, 169, 170, 9, 2, 2, 2, 170,
	403, 7, 109, 2, 2, 171, 173, 9, 2, 2, 2, 172, 174, 9, 3, 2, 2, 173, 172,
	3, 2, 2, 2, 173, 174, 3, 2, 2, 2, 174, 175, 3, 2, 2, 2, 175, 403, 7, 132,
	2, 2, 176, 177, 9, 2, 2, 2, 177, 178, 7, 131, 2, 2, 178, 403, 7, 144, 2,
	2, 179, 180, 9, 2, 2, 2, 180, 403, 7, 96, 2, 2, 181, 182, 9, 2, 2, 2, 182,
	403, 7, 143, 2, 2, 183, 184, 7, 90, 2, 2, 184, 186, 5, 114, 58, 2, 185,
	187, 7, 91, 2, 2, 186, 185, 3, 2, 2, 2, 186, 187, 3, 2, 2, 2, 187, 403,
	3, 2, 2, 2, 188, 189, 7, 90, 2, 2, 189, 191, 7, 86, 2, 2, 190, 192, 7,
	91, 2, 2, 191, 190, 3, 2, 2, 2, 191, 192, 3, 2, 2, 2, 192, 403, 3, 2, 2,
	2, 193, 194, 7, 90, 2, 2, 194, 195, 7, 110, 2, 2, 195, 403, 5, 106, 54,
	2, 196, 197, 7, 90, 2, 2, 197, 198, 7, 131, 2, 2, 198, 403, 5, 106, 54,
	2, 199, 202, 7, 92, 2, 2, 200, 203, 5, 106, 54, 2, 201, 203, 7, 161, 2,
	2, 202, 200, 3, 2, 2, 2, 202, 201, 3, 2, 2, 2, 203, 204, 3, 2, 2, 2, 204,
	403, 5, 30, 16, 2, 205, 206, 9, 2, 2, 2, 206, 208, 7, 103, 2, 2, 207, 209,
	7, 91, 2, 2, 208, 207, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 403, 3, 2,
	2, 2, 210, 211, 7, 104, 2, 2, 211, 403, 5, 106, 54, 2, 212, 213, 7, 104,
	2, 2, 213, 403, 7, 17, 2, 2, 214, 215, 7, 116, 2, 2, 215, 216, 7, 161,
	2, 2, 216, 217, 7, 146, 2, 2, 217, 403, 7, 161, 2, 2, 218, 219, 7, 126,
	2, 2, 219, 403, 7, 161, 2, 2, 220, 221, 7, 117, 2, 2, 221, 222, 5, 110,
	56, 2, 222, 223, 7, 146, 2, 2, 223, 224, 5, 112, 57, 2, 224, 403, 3, 2,
	2, 2, 225, 226, 7, 118, 2, 2, 226, 403, 5, 110, 56, 2, 227, 230, 7, 82,
	2, 2, 228, 229, 7, 27, 2, 2, 229, 231, 7, 139, 2, 2, 230, 228, 3, 2, 2,
	2, 230, 231, 3, 2, 2, 2, 231, 233, 3, 2, 2, 2, 232, 234, 7, 134, 2, 2,
	233, 232, 3, 2, 2, 2, 233, 234, 3, 2, 2, 2, 234, 235, 3, 2, 2, 2, 235,
	239, 7, 85, 2, 2, 236, 237, 7, 145, 2, 2, 237, 238, 7, 30, 2, 2, 238, 240,
	7, 31, 2, 2, 239, 236, 3, 2, 2, 2, 239, 240, 3, 2, 2, 2, 240, 241, 3, 2,
	2, 2, 241, 243, 5, 114, 58, 2, 242, 244, 5, 22, 12, 2, 243, 242, 3, 2,
	2, 2, 243, 244, 3, 2, 2, 2, 244, 247, 3, 2, 2, 2, 245, 246, 7, 80, 2, 2,
	246, 248, 5, 26, 14, 2, 247, 245, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 248,
	403, 3, 2, 2, 2, 249, 252, 7, 82, 2, 2, 250, 251, 7, 27, 2, 2, 251, 253,
	7, 139, 2, 2, 252, 250, 3, 2, 2, 2, 252, 253, 3, 2, 2, 2, 253, 254, 3,
	2, 2, 2, 254, 258, 7, 85, 2, 2, 255, 256, 7, 145, 2, 2, 256, 257, 7, 30,
	2, 2, 257, 259, 7, 31, 2, 2, 258, 255, 3, 2, 2, 2, 258, 259, 3, 2, 2, 2,
	259, 260, 3, 2, 2, 2, 260, 263, 5, 114, 58, 2, 261, 262, 7, 80, 2, 2, 262,
	264, 5, 26, 14, 2, 263, 261, 3, 2, 2, 2, 263, 264, 3, 2, 2, 2, 264, 265,
	3, 2, 2, 2, 265, 266, 7, 16, 2, 2, 266, 267, 5, 16, 9, 2, 267, 403, 3,
	2, 2, 2, 268, 271, 7, 82, 2, 2, 269, 270, 7, 27, 2, 2, 270, 272, 7, 139,
	2, 2, 271, 269, 3, 2, 2, 2, 271, 272, 3, 2, 2, 2, 272, 274, 3, 2, 2, 2,
	273, 275, 7, 134, 2, 2, 274, 273, 3, 2, 2, 2, 274, 275, 3, 2, 2, 2, 275,
	276, 3, 2, 2, 2, 276, 280, 7, 83, 2, 2, 277, 278, 7, 145, 2, 2, 278, 279,
	7, 30, 2, 2, 279, 281, 7, 31, 2, 2, 280, 277, 3, 2, 2, 2, 280, 281, 3,
	2, 2, 2, 281, 282, 3, 2, 2, 2, 282, 284, 5, 114, 58, 2, 283, 285, 5, 22,
	12, 2, 284, 283, 3, 2, 2, 2, 284, 285, 3, 2, 2, 2, 285, 288, 3, 2, 2, 2,
	286, 287, 7, 80, 2, 2, 287, 289, 5, 26, 14, 2, 288, 286, 3, 2, 2, 2, 288,
	289, 3, 2, 2, 2, 289, 403, 3, 2, 2, 2, 290, 293, 7, 82, 2, 2, 291, 292,
	7, 27, 2, 2, 292, 294, 7, 139, 2, 2, 293, 291, 3, 2, 2, 2, 293, 294, 3,
	2, 2, 2, 294, 295, 3, 2, 2, 2, 295, 299, 7, 83, 2, 2, 296, 297, 7, 145,
	2, 2, 297, 298, 7, 30, 2, 2, 298, 300, 7, 31, 2, 2, 299, 296, 3, 2, 2,
	2, 299, 300, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 304, 5, 114, 58, 2,
	302, 303, 7, 80, 2, 2, 303, 305, 5, 26, 14, 2, 304, 302, 3, 2, 2, 2, 304,
	305, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 307, 7, 16, 2, 2, 307, 308,
	5, 16, 9, 2, 308, 403, 3, 2, 2, 2, 309, 310, 7, 82, 2, 2, 310, 311, 9,
	3, 2, 2, 311, 315, 7, 131, 2, 2, 312, 313, 7, 145, 2, 2, 313, 314, 7, 30,
	2, 2, 314, 316, 7, 31, 2, 2, 315, 312, 3, 2, 2, 2, 315, 316, 3, 2, 2, 2,
	316, 317, 3, 2, 2, 2, 317, 318, 5, 106, 54, 2, 318, 319, 7, 80, 2, 2, 319,
	320, 5, 26, 14, 2, 320, 403, 3, 2, 2, 2, 321, 322, 7, 87, 2, 2, 322, 323,
	7, 89, 2, 2, 323, 326, 5, 114, 58, 2, 324, 325, 7, 80, 2, 2, 325, 327,
	5, 26, 14, 2, 326, 324, 3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 328, 3,
	2, 2, 2, 328, 329, 5, 16, 9, 2, 329, 403, 3, 2, 2, 2, 330, 331, 7, 87,
	2, 2, 331, 332, 7, 89, 2, 2, 332, 334, 5, 114, 58, 2, 333, 335, 5, 74,
	38, 2, 334, 333, 3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2,
	336, 337, 7, 81, 2, 2, 337, 338, 5, 54, 28, 2, 338, 403, 3, 2, 2, 2, 339,
	340, 7, 111, 2, 2, 340, 343, 7, 85, 2, 2, 341, 342, 7, 145, 2, 2, 342,
	344, 7, 31, 2, 2, 343, 341, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 345,
	3, 2, 2, 2, 345, 348, 5, 114, 58, 2, 346, 347, 7, 88, 2, 2, 347, 349, 7,
	84, 2, 2, 348, 346, 3, 2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 403, 3, 2, 2,
	2, 350, 351, 7, 111, 2, 2, 351, 354, 7, 83, 2, 2, 352, 353, 7, 145, 2,
	2, 353, 355, 7, 31, 2, 2, 354, 352, 3, 2, 2, 2, 354, 355, 3, 2, 2, 2, 355,
	356, 3, 2, 2, 2, 356, 359, 5, 114, 58, 2, 357, 358, 7, 88, 2, 2, 358, 360,
	7, 84, 2, 2, 359, 357, 3, 2, 2, 2, 359, 360, 3, 2, 2, 2, 360, 403, 3, 2,
	2, 2, 361, 362, 7, 111, 2, 2, 362, 365, 7, 131, 2, 2, 363, 364, 7, 145,
	2, 2, 364, 366, 7, 31, 2, 2, 365, 363, 3, 2, 2, 2, 365, 366, 3, 2, 2, 2,
	366, 367, 3, 2, 2, 2, 367, 403, 5, 106, 54, 2, 368, 371, 7, 93, 2, 2, 369,
	372, 5, 10, 6, 2, 370, 372, 5, 106, 54, 2, 371, 369, 3, 2, 2, 2, 371, 370,
	3, 2, 2, 2, 372, 403, 3, 2, 2, 2, 373, 374, 7, 82, 2, 2, 374, 378, 7, 95,
	2, 2, 375, 376, 7, 145, 2, 2, 376, 377, 7, 30, 2, 2, 377, 379, 7, 31, 2,
	2, 378, 375, 3, 2, 2, 2, 378, 379, 3, 2, 2, 2, 379, 380, 3, 2, 2, 2, 380,
	381, 5, 106, 54, 2, 381, 382, 7, 16, 2, 2, 382, 383, 5, 98, 50, 2, 383,
	403, 3, 2, 2, 2, 384, 385, 7, 111, 2, 2, 385, 388, 7, 95, 2, 2, 386, 387,
	7, 145, 2, 2, 387, 389, 7, 31, 2, 2, 388, 386, 3, 2, 2, 2, 388, 389, 3,
	2, 2, 2, 389, 390, 3, 2, 2, 2, 390, 403, 5, 106, 54, 2, 391, 392, 7, 142,
	2, 2, 392, 393, 9, 4, 2, 2, 393, 394, 5, 114, 58, 2, 394, 399, 5, 20, 11,
	2, 395, 396, 7, 4, 2, 2, 396, 398, 5, 20, 11, 2, 397, 395, 3, 2, 2, 2,
	398, 401, 3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400,
	403, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 402, 148, 3, 2, 2, 2, 402, 149,
	3, 2, 2, 2, 402, 151, 3, 2, 2, 2, 402, 159, 3, 2, 2, 2, 402, 164, 3, 2,
	2, 2, 402, 169, 3, 2, 2, 2, 402, 171, 3, 2, 2, 2, 402, 176, 3, 2, 2, 2,
	402, 179, 3, 2, 2, 2, 402, 181, 3, 2, 2, 2, 402, 183, 3, 2, 2, 2, 402,
	188, 3, 2, 2, 2, 402, 193, 3, 2, 2, 2, 402, 196, 3, 2, 2, 2, 402, 199,
	3, 2, 2, 2, 402, 205, 3, 2, 2, 2, 402, 210, 3, 2, 2, 2, 402, 212, 3, 2,
	2, 2, 402, 214, 3, 2, 2, 2, 402, 218, 3, 2, 2, 2, 402, 220, 3, 2, 2, 2,
	402, 225, 3, 2, 2, 2, 402, 227, 3, 2, 2, 2, 402, 249, 3, 2, 2, 2, 402,
	268, 3, 2, 2, 2, 402, 290, 3, 2, 2, 2, 402, 309, 3, 2, 2, 2, 402, 321,
	3, 2, 2, 2, 402, 330, 3, 2, 2, 2, 402, 339, 3, 2, 2, 2, 402, 350, 3, 2,
	2, 2, 402, 361, 3, 2, 2, 2, 402, 368, 3, 2, 2, 2, 402, 373, 3, 2, 2, 2,
	402, 384, 3, 2, 2, 2, 402, 391, 3, 2, 2, 2, 403, 11, 3, 2, 2, 2, 404, 405,
	7, 140, 2, 2, 405, 406, 7, 81, 2, 2, 406, 408, 5, 114, 58, 2, 407, 409,
	5, 74, 38, 2, 408, 407, 3, 2, 2, 2, 408, 409, 3, 2, 2, 2, 409, 410, 3,
	2, 2, 2, 410, 411, 7, 81, 2, 2, 411, 412, 5, 54, 28, 2, 412, 444, 3, 2,
	2, 2, 413, 414, 7, 140, 2, 2, 414, 415, 7, 36, 2, 2, 415, 416, 7, 81, 2,
	2, 416, 418, 5, 114, 58, 2, 417, 419, 5, 74, 38, 2, 418, 417, 3, 2, 2,
	2, 418, 419, 3, 2, 2, 2, 419, 420, 3, 2, 2, 2, 420, 421, 7, 130, 2, 2,
	421, 422, 5, 54, 28, 2, 422, 444, 3, 2, 2, 2, 423, 424, 7, 140, 2, 2, 424,
	425, 7, 85, 2, 2, 425, 427, 5, 114, 58, 2, 426, 428, 5, 22, 12, 2, 427,
	426, 3, 2, 2, 2, 427, 428, 3, 2, 2, 2, 428, 431, 3, 2, 2, 2, 429, 430,
	7, 80, 2, 2, 430, 432, 5, 26, 14, 2, 431, 429, 3, 2, 2, 2, 431, 432, 3,
	2, 2, 2, 432, 444, 3, 2, 2, 2, 433, 434, 7, 140, 2, 2, 434, 435, 7, 83,
	2, 2, 435, 437, 5, 114, 58, 2, 436, 438, 5, 22, 12, 2, 437, 436, 3, 2,
	2, 2, 437, 438, 3, 2, 2, 2, 438, 441, 3, 2, 2, 2, 439, 440, 7, 80, 2, 2,
	440, 442, 5, 26, 14, 2, 441, 439, 3, 2, 2, 2, 441, 442, 3, 2, 2, 2, 442,
	444, 3, 2, 2, 2, 443, 404, 3, 2, 2, 2, 443, 413, 3, 2, 2, 2, 443, 423,
	3, 2, 2, 2, 443, 433, 3, 2, 2, 2, 444, 13, 3, 2, 2, 2, 445, 446, 7, 127,
	2, 2, 446, 447, 7, 128, 2, 2, 447, 448, 7, 161, 2, 2, 448, 15, 3, 2, 2,
	2, 449, 450, 7, 14, 2, 2, 450, 455, 5, 56, 29, 2, 451, 452, 7, 4, 2, 2,
	452, 454, 5, 56, 29, 2, 453, 451, 3, 2, 2, 2, 454, 457, 3, 2, 2, 2, 455,
	453, 3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 456, 458, 3, 2, 2, 2, 457, 455,
	3, 2, 2, 2, 458, 459, 7, 15, 2, 2, 459, 462, 5, 58, 30, 2, 460, 461, 7,
	21, 2, 2, 461, 463, 5, 40, 21, 2, 462, 460, 3, 2, 2, 2, 462, 463, 3, 2,
	2, 2, 463, 466, 3, 2, 2, 2, 464, 465, 7, 19, 2, 2, 465, 467, 5, 80, 41,
	2, 466, 464, 3, 2, 2, 2, 466, 467, 3, 2, 2, 2, 467, 471, 3, 2, 2, 2, 468,
	469, 7, 22, 2, 2, 469, 470, 7, 23, 2, 2, 470, 472, 5, 50, 26, 2, 471, 468,
	3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472, 476, 3, 2, 2, 2, 473, 474, 7, 78,
	2, 2, 474, 475, 7, 23, 2, 2, 475, 477, 5, 52, 27, 2, 476, 473, 3, 2, 2,
	2, 476, 477, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478, 479, 7, 24, 2, 2, 479,
	481, 5, 80, 41, 2, 480, 478, 3, 2, 2, 2, 480, 481, 3, 2, 2, 2, 481, 484,
	3, 2, 2, 2, 482, 483, 7, 11, 2, 2, 483, 485, 5, 18, 10, 2, 484, 482, 3,
	2, 2, 2, 484, 485, 3, 2, 2, 2, 485, 487, 3, 2, 2, 2, 486, 488, 5, 34, 18,
	2, 487, 486, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 17, 3, 2, 2, 2, 489,
	490, 9, 5, 2, 2, 490, 19, 3, 2, 2, 2, 491, 493, 7, 141, 2, 2, 492, 494,
	7, 107, 2, 2, 493, 492, 3, 2, 2, 2, 493, 494, 3, 2, 2, 2, 494, 495, 3,
	2, 2, 2, 495, 496, 5, 106, 54, 2, 496, 497, 5, 98, 50, 2, 497, 21, 3, 2,
	2, 2, 498, 499, 7, 5, 2, 2, 499, 504, 5, 24, 13, 2, 500, 501, 7, 4, 2,
	2, 501, 503, 5, 24, 13, 2, 502, 500, 3, 2, 2, 2, 503, 506, 3, 2, 2, 2,
	504, 502, 3, 2, 2, 2, 504, 505, 3, 2, 2, 2, 505, 507, 3, 2, 2, 2, 506,
	504, 3, 2, 2, 2, 507, 508, 7, 6, 2, 2, 508, 23, 3, 2, 2, 2, 509, 510, 5,
	106, 54, 2, 510, 515, 5, 98, 50, 2, 511, 513, 7, 138, 2, 2, 512, 511, 3,
	2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 516, 7, 130,
	2, 2, 515, 512, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 25, 3, 2, 2, 2,
	517, 518, 7, 5, 2, 2, 518, 523, 5, 28, 15, 2, 519, 520, 7, 4, 2, 2, 520,
	522, 5, 28, 15, 2, 521, 519, 3, 2, 2, 2, 522, 525, 3, 2, 2, 2, 523, 521,
	3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 526, 3, 2, 2, 2, 525, 523, 3, 2,
	2, 2, 526, 527, 7, 6, 2, 2, 527, 27, 3, 2, 2, 2, 528, 531, 5, 106, 54,
	2, 529, 531, 7, 161, 2, 2, 530, 528, 3, 2, 2, 2, 530, 529, 3, 2, 2, 2,
	531, 532, 3, 2, 2, 2, 532, 533, 7, 146, 2, 2, 533, 534, 5, 118, 60, 2,
	534, 29, 3, 2, 2, 2, 535, 536, 7, 15, 2, 2, 536, 538, 7, 125, 2, 2, 537,
	535, 3, 2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 540, 3, 2, 2, 2, 539, 541,
	5, 32, 17, 2, 540, 539, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 543, 3,
	2, 2, 2, 542, 544, 5, 34, 18, 2, 543, 542, 3, 2, 2, 2, 543, 544, 3, 2,
	2, 2, 544, 31, 3, 2, 2, 2, 545, 546, 9, 6, 2, 2, 546, 547, 5, 116, 59,
	2, 547, 33, 3, 2, 2, 2, 548, 549, 7, 25, 2, 2, 549, 550, 5, 116, 59, 2,
	550, 35, 3, 2, 2, 2, 551, 552, 7, 63, 2, 2, 552, 553, 5, 116, 59, 2, 553,
	554, 5, 48, 25, 2, 554, 37, 3, 2, 2, 2, 555, 556, 7, 64, 2, 2, 556, 557,
	7, 65, 2, 2, 557, 558, 5, 116, 59, 2, 558, 559, 5, 48, 25, 2, 559, 39,
	3, 2, 2, 2, 560, 562, 7, 165, 2, 2, 561, 560, 3, 2, 2, 2, 561, 562, 3,
	2, 2, 2, 562, 566, 3, 2, 2, 2, 563, 567, 5, 42, 22, 2, 564, 567, 5, 44,
	23, 2, 565, 567, 5, 46, 24, 2, 566, 563, 3, 2, 2, 2, 566, 564, 3, 2, 2,
	2, 566, 565, 3, 2, 2, 2, 567, 41, 3, 2, 2, 2, 568, 569, 7, 59, 2, 2, 569,
	570, 7, 5, 2, 2, 570, 571, 7, 61, 2, 2, 571, 572, 5, 116, 59, 2, 572, 575,
	5, 48, 25, 2, 573, 574, 7, 4, 2, 2, 574, 576, 5, 36, 19, 2, 575, 573, 3,
	2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 579, 3, 2, 2, 2, 577, 578, 7, 4, 2,
	2, 578, 580, 5, 38, 20, 2, 579, 577, 3, 2, 2, 2, 579, 580, 3, 2, 2, 2,
	580, 581, 3, 2, 2, 2, 581, 582, 7, 6, 2, 2, 582, 43, 3, 2, 2, 2, 583, 584,
	7, 60, 2, 2, 584, 585, 7, 5, 2, 2, 585, 586, 7, 61, 2, 2, 586, 587, 5,
	116, 59, 2, 587, 588, 5, 48, 25, 2, 588, 589, 7, 4, 2, 2, 589, 590, 7,
	62, 2, 2, 590, 591, 7, 23, 2, 2, 591, 592, 5, 116, 59, 2, 592, 595, 5,
	48, 25, 2, 593, 594, 7, 4, 2, 2, 594, 596, 5, 36, 19, 2, 595, 593, 3, 2,
	2, 2, 595, 596, 3, 2, 2, 2, 596, 599, 3, 2, 2, 2, 597, 598, 7, 4, 2, 2,
	598, 600, 5, 38, 20, 2, 599, 597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600,
	601, 3, 2, 2, 2, 601, 602, 7, 6, 2, 2, 602, 45, 3, 2, 2, 2, 603, 604, 7,
	120, 2, 2, 604, 605, 7, 5, 2, 2, 605, 606, 5, 116, 59, 2, 606, 609, 5,
	48, 25, 2, 607, 608, 7, 4, 2, 2, 608, 610, 5, 36, 19, 2, 609, 607, 3, 2,
	2, 2, 609, 610, 3, 2, 2, 2, 610, 613, 3, 2, 2, 2, 611, 612, 7, 4, 2, 2,
	612, 614, 5, 38, 20, 2, 613, 611, 3, 2, 2, 2, 613, 614, 3, 2, 2, 2, 614,
	615, 3, 2, 2, 2, 615, 616, 7, 6, 2, 2, 616, 47, 3, 2, 2, 2, 617, 618, 9,
	7, 2, 2, 618, 49, 3, 2, 2, 2, 619, 624, 5, 86, 44, 2, 620, 621, 7, 4, 2,
	2, 621, 623, 5, 86, 44, 2, 622, 620, 3, 2, 2, 2, 623, 626, 3, 2, 2, 2,
	624, 622, 3, 2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 640, 3, 2, 2, 2, 626,
	624, 3, 2, 2, 2, 627, 636, 7, 5, 2, 2, 628, 633, 5, 86, 44, 2, 629, 630,
	7, 4, 2, 2, 630, 632, 5, 86, 44, 2, 631, 629, 3, 2, 2, 2, 632, 635, 3,
	2, 2, 2, 633, 631, 3, 2, 2, 2, 633, 634, 3, 2, 2, 2, 634, 637, 3, 2, 2,
	2, 635, 633, 3, 2, 2, 2, 636, 628, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637,
	638, 3, 2, 2, 2, 638, 640, 7, 6, 2, 2, 639, 619, 3, 2, 2, 2, 639, 627,
	3, 2, 2, 2, 640, 51, 3, 2, 2, 2, 641, 646, 5, 86, 44, 2, 642, 643, 7, 4,
	2, 2, 643, 645, 5, 86, 44, 2, 644, 642, 3, 2, 2, 2, 645, 648, 3, 2, 2,
	2, 646, 644, 3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647, 662, 3, 2, 2, 2, 648,
	646, 3, 2, 2, 2, 649, 658, 7, 5, 2, 2, 650, 655, 5, 86, 44, 2, 651, 652,
	7, 4, 2, 2, 652, 654, 5, 86, 44, 2, 653, 651, 3, 2, 2, 2, 654, 657, 3,
	2, 2, 2, 655, 653, 3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 659, 3, 2, 2,
	2, 657, 655, 3, 2, 2, 2, 658, 650, 3, 2, 2, 2, 658, 659, 3, 2, 2, 2, 659,
	660, 3, 2, 2, 2, 660, 662, 7, 6, 2, 2, 661, 641, 3, 2, 2, 2, 661, 649,
	3, 2, 2, 2, 662, 53, 3, 2, 2, 2, 663, 672, 7, 5, 2, 2, 664, 669, 5, 86,
	44, 2, 665, 666, 7, 4, 2, 2, 666, 668, 5, 86, 44, 2, 667, 665, 3, 2, 2,
	2, 668, 671, 3, 2, 2, 2, 669, 667, 3, 2, 2, 2, 669, 670, 3, 2, 2, 2, 670,
	673, 3, 2, 2, 2, 671, 669, 3, 2, 2, 2, 672, 664, 3, 2, 2, 2, 672, 673,
	3, 2, 2, 2, 673, 674, 3, 2, 2, 2, 674, 675, 7, 6, 2, 2, 675, 55, 3, 2,
	2, 2, 676, 681, 5, 78, 40, 2, 677, 679, 7, 16, 2, 2, 678, 677, 3, 2, 2,
	2, 678, 679, 3, 2, 2, 2, 679, 680, 3, 2, 2, 2, 680, 682, 5, 106, 54, 2,
	681, 678, 3, 2, 2, 2, 681, 682, 3, 2, 2, 2, 682, 689, 3, 2, 2, 2, 683,
	684, 5, 106, 54, 2, 684, 685, 7, 7, 2, 2, 685, 686, 7, 154, 2, 2, 686,
	689, 3, 2, 2, 2, 687, 689, 7, 154, 2, 2, 688, 676, 3, 2, 2, 2, 688, 683,
	3, 2, 2, 2, 688, 687, 3, 2, 2, 2, 689, 57, 3, 2, 2, 2, 690, 692, 5, 72,
	37, 2, 691, 693, 5, 60, 31, 2, 692, 691, 3, 2, 2, 2, 693, 694, 3, 2, 2,
	2, 694, 692, 3, 2, 2, 2, 694, 695, 3, 2, 2, 2, 695, 698, 3, 2, 2, 2, 696,
	698, 5, 72, 37, 2, 697, 690, 3, 2, 2, 2, 697, 696, 3, 2, 2, 2, 698, 59,
	3, 2, 2, 2, 699, 700, 5, 62, 32, 2, 700, 701, 7, 71, 2, 2, 701, 703, 5,
	72, 37, 2, 702, 704, 5, 64, 33, 2, 703, 702, 3, 2, 2, 2, 703, 704, 3, 2,
	2, 2, 704, 705, 3, 2, 2, 2, 705, 706, 5, 70, 36, 2, 706, 61, 3, 2, 2, 2,
	707, 709, 7, 74, 2, 2, 708, 707, 3, 2, 2, 2, 708, 709, 3, 2, 2, 2, 709,
	719, 3, 2, 2, 2, 710, 712, 7, 72, 2, 2, 711, 713, 7, 73, 2, 2, 712, 711,
	3, 2, 2, 2, 712, 713, 3, 2, 2, 2, 713, 719, 3, 2, 2, 2, 714, 716, 7, 75,
	2, 2, 715, 717, 7, 73, 2, 2, 716, 715, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2,
	717, 719, 3, 2, 2, 2, 718, 708, 3, 2, 2, 2, 718, 710, 3, 2, 2, 2, 718,
	714, 3, 2, 2, 2, 719, 63, 3, 2, 2, 2, 720, 721, 7, 20, 2, 2, 721, 722,
	5, 66, 34, 2, 722, 65, 3, 2, 2, 2, 723, 724, 7, 5, 2, 2, 724, 725, 5, 68,
	35, 2, 725, 726, 7, 4, 2, 2, 726, 727, 5, 68, 35, 2, 727, 729, 7, 6, 2,
	2, 728, 730, 5, 38, 20, 2, 729, 728, 3, 2, 2, 2, 729, 730, 3, 2, 2, 2,
	730, 736, 3, 2, 2, 2, 731, 733, 5, 68, 35, 2, 732, 734, 5, 38, 20, 2, 733,
	732, 3, 2, 2, 2, 733, 734, 3, 2, 2, 2, 734, 736, 3, 2, 2, 2, 735, 723,
	3, 2, 2, 2, 735, 731, 3, 2, 2, 2, 736, 67, 3, 2, 2, 2, 737, 738, 5, 116,
	59, 2, 738, 739, 5, 48, 25, 2, 739, 69, 3, 2, 2, 2, 740, 741, 7, 77, 2,
	2, 741, 742, 5, 80, 41, 2, 742, 71, 3, 2, 2, 2, 743, 748, 5, 76, 39, 2,
	744, 746, 7, 16, 2, 2, 745, 744, 3, 2, 2, 2, 745, 746, 3, 2, 2, 2, 746,
	747, 3, 2, 2, 2, 747, 749, 5, 114, 58, 2, 748, 745, 3, 2, 2, 2, 748, 749,
	3, 2, 2, 2, 749, 73, 3, 2, 2, 2, 750, 751, 7, 5, 2, 2, 751, 756, 5, 106,
	54, 2, 752, 753, 7, 4, 2, 2, 753, 755, 5, 106, 54, 2, 754, 752, 3, 2, 2,
	2, 755, 758, 3, 2, 2, 2, 756, 754, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757,
	759, 3, 2, 2, 2, 758, 756, 3, 2, 2, 2, 759, 760, 7, 6, 2, 2, 760, 75, 3,
	2, 2, 2, 761, 762, 5, 114, 58, 2, 762, 77, 3, 2, 2, 2, 763, 764, 5, 80,
	41, 2, 764, 79, 3, 2, 2, 2, 765, 766, 8, 41, 1, 2, 766, 770, 5, 82, 42,
	2, 767, 768, 7, 30, 2, 2, 768, 770, 5, 80, 41, 5, 769, 765, 3, 2, 2, 2,
	769, 767, 3, 2, 2, 2, 770, 779, 3, 2, 2, 2, 771, 772, 12, 4, 2, 2, 772,
	773, 7, 28, 2, 2, 773, 778, 5, 80, 41, 5, 774, 775, 12, 3, 2, 2, 775, 776,
	7, 27, 2, 2, 776, 778, 5, 80, 41, 4, 777, 771, 3, 2, 2, 2, 777, 774, 3,
	2, 2, 2, 778, 781, 3, 2, 2, 2, 779, 777, 3, 2, 2, 2, 779, 780, 3, 2, 2,
	2, 780, 81, 3, 2, 2, 2, 781, 779, 3, 2, 2, 2, 782, 784, 5, 86, 44, 2, 783,
	785, 5, 84, 43, 2, 784, 783, 3, 2, 2, 2, 784, 785, 3, 2, 2, 2, 785, 83,
	3, 2, 2, 2, 786, 787, 5, 94, 48, 2, 787, 788, 5, 86, 44, 2, 788, 834, 3,
	2, 2, 2, 789, 791, 7, 30, 2, 2, 790, 789, 3, 2, 2, 2, 790, 791, 3, 2, 2,
	2, 791, 792, 3, 2, 2, 2, 792, 793, 7, 32, 2, 2, 793, 794, 5, 86, 44, 2,
	794, 795, 7, 28, 2, 2, 795, 796, 5, 86, 44, 2, 796, 834, 3, 2, 2, 2, 797,
	799, 7, 30, 2, 2, 798, 797, 3, 2, 2, 2, 798, 799, 3, 2, 2, 2, 799, 800,
	3, 2, 2, 2, 800, 801, 7, 29, 2, 2, 801, 802, 7, 5, 2, 2, 802, 807, 5, 78,
	40, 2, 803, 804, 7, 4, 2, 2, 804, 806, 5, 78, 40, 2, 805, 803, 3, 2, 2,
	2, 806, 809, 3, 2, 2, 2, 807, 805, 3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808,
	810, 3, 2, 2, 2, 809, 807, 3, 2, 2, 2, 810, 811, 7, 6, 2, 2, 811, 834,
	3, 2, 2, 2, 812, 814, 7, 30, 2, 2, 813, 812, 3, 2, 2, 2, 813, 814, 3, 2,
	2, 2, 814, 815, 3, 2, 2, 2, 815, 816, 7, 33, 2, 2, 816, 819, 5, 86, 44,
	2, 817, 818, 7, 34, 2, 2, 818, 820, 7, 161, 2, 2, 819, 817, 3, 2, 2, 2,
	819, 820, 3, 2, 2, 2, 820, 834, 3, 2, 2, 2, 821, 823, 7, 35, 2, 2, 822,
	824, 7, 30, 2, 2, 823, 822, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824, 825,
	3, 2, 2, 2, 825, 834, 7, 36, 2, 2, 826, 828, 7, 35, 2, 2, 827, 829, 7,
	30, 2, 2, 828, 827, 3, 2, 2, 2, 828, 829, 3, 2, 2, 2, 829, 830, 3, 2, 2,
	2, 830, 831, 7, 18, 2, 2, 831, 832, 7, 15, 2, 2, 832, 834, 5, 86, 44, 2,
	833, 786, 3, 2, 2, 2, 833, 790, 3, 2, 2, 2, 833, 798, 3, 2, 2, 2, 833,
	813, 3, 2, 2, 2, 833, 821, 3, 2, 2, 2, 833, 826, 3, 2, 2, 2, 834, 85, 3,
	2, 2, 2, 835, 836, 8, 44, 1, 2, 836, 840, 5, 88, 45, 2, 837, 838, 9, 8,
	2, 2, 838, 840, 5, 86, 44, 6, 839, 835, 3, 2, 2, 2, 839, 837, 3, 2, 2,
	2, 840, 855, 3, 2, 2, 2, 841, 842, 12, 5, 2, 2, 842, 843, 9, 9, 2, 2, 843,
	854, 5, 86, 44, 6, 844, 845, 12, 4, 2, 2, 845, 846, 9, 8, 2, 2, 846, 854,
	5, 86, 44, 5, 847, 848, 12, 3, 2, 2, 848, 849, 7, 157, 2, 2, 849, 854,
	5, 86, 44, 4, 850, 851, 12, 7, 2, 2, 851, 852, 7, 26, 2, 2, 852, 854, 5,
	92, 47, 2, 853, 841, 3, 2, 2, 2, 853, 844, 3, 2, 2, 2, 853, 847, 3, 2,
	2, 2, 853, 850, 3, 2, 2, 2, 854, 857, 3, 2, 2, 2, 855, 853, 3, 2, 2, 2,
	855, 856, 3, 2, 2, 2, 856, 87, 3, 2, 2, 2, 857, 855, 3, 2, 2, 2, 858, 859,
	8, 45, 1, 2, 859, 980, 5, 118, 60, 2, 860, 861, 5, 106, 54, 2, 861, 862,
	7, 161, 2, 2, 862, 980, 3, 2, 2, 2, 863, 864, 7, 66, 2, 2, 864, 866, 5,
	86, 44, 2, 865, 867, 5, 104, 53, 2, 866, 865, 3, 2, 2, 2, 867, 868, 3,
	2, 2, 2, 868, 866, 3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 872, 3, 2, 2,
	2, 870, 871, 7, 69, 2, 2, 871, 873, 5, 78, 40, 2, 872, 870, 3, 2, 2, 2,
	872, 873, 3, 2, 2, 2, 873, 874, 3, 2, 2, 2, 874, 875, 7, 70, 2, 2, 875,
	980, 3, 2, 2, 2, 876, 878, 7, 66, 2, 2, 877, 879, 5, 104, 53, 2, 878, 877,
	3, 2, 2, 2, 879, 880, 3, 2, 2, 2, 880, 878, 3, 2, 2, 2, 880, 881, 3, 2,
	2, 2, 881, 884, 3, 2, 2, 2, 882, 883, 7, 69, 2, 2, 883, 885, 5, 78, 40,
	2, 884, 882, 3, 2, 2, 2, 884, 885, 3, 2, 2, 2, 885, 886, 3, 2, 2, 2, 886,
	887, 7, 70, 2, 2, 887, 980, 3, 2, 2, 2, 888, 889, 7, 97, 2, 2, 889, 890,
	7, 5, 2, 2, 890, 891, 5, 78, 40, 2, 891, 892, 7, 16, 2, 2, 892, 893, 5,
	98, 50, 2, 893, 894, 7, 6, 2, 2, 894, 980, 3, 2, 2, 2, 895, 896, 7, 114,
	2, 2, 896, 905, 7, 8, 2, 2, 897, 902, 5, 78, 40, 2, 898, 899, 7, 4, 2,
	2, 899, 901, 5, 78, 40, 2, 900, 898, 3, 2, 2, 2, 901, 904, 3, 2, 2, 2,
	902, 900, 3, 2, 2, 2, 902, 903, 3, 2, 2, 2, 903, 906, 3, 2, 2, 2, 904,
	902, 3, 2, 2, 2, 905, 897, 3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 907,
	3, 2, 2, 2, 907, 980, 7, 9, 2, 2, 908, 909, 7, 115, 2, 2, 909, 923, 7,
	5, 2, 2, 910, 911, 5, 78, 40, 2, 911, 912, 7, 158, 2, 2, 912, 920, 5, 78,
	40, 2, 913, 914, 7, 4, 2, 2, 914, 915, 5, 78, 40, 2, 915, 916, 7, 158,
	2, 2, 916, 917, 5, 78, 40, 2, 917, 919, 3, 2, 2, 2, 918, 913, 3, 2, 2,
	2, 919, 922, 3, 2, 2, 2, 920, 918, 3, 2, 2, 2, 920, 921, 3, 2, 2, 2, 921,
	924, 3, 2, 2, 2, 922, 920, 3, 2, 2, 2, 923, 910, 3, 2, 2, 2, 923, 924,
	3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 980, 7, 6, 2, 2, 926, 927, 7, 79,
	2, 2, 927, 941, 7, 5, 2, 2, 928, 929, 5, 106, 54, 2, 929, 930, 7, 158,
	2, 2, 930, 938, 5, 78, 40, 2, 931, 932, 7, 4, 2, 2, 932, 933, 5, 106, 54,
	2, 933, 934, 7, 158, 2, 2, 934, 935, 5, 78, 40, 2, 935, 937, 3, 2, 2, 2,
	936, 931, 3, 2, 2, 2, 937, 940, 3, 2, 2, 2, 938, 936, 3, 2, 2, 2, 938,
	939, 3, 2, 2, 2, 939, 942, 3, 2, 2, 2, 940, 938, 3, 2, 2, 2, 941, 928,
	3, 2, 2, 2, 941, 942, 3, 2, 2, 2, 942, 943, 3, 2, 2, 2, 943, 980, 7, 6,
	2, 2, 944, 945, 5, 106, 54, 2, 945, 946, 7, 5, 2, 2, 946, 947, 7, 154,
	2, 2, 947, 948, 7, 6, 2, 2, 948, 980, 3, 2, 2, 2, 949, 950, 5, 106, 54,
	2, 950, 966, 7, 5, 2, 2, 951, 956, 5, 90, 46, 2, 952, 953, 7, 4, 2, 2,
	953, 955, 5, 90, 46, 2, 954, 952, 3, 2, 2, 2, 955, 958, 3, 2, 2, 2, 956,
	954, 3, 2, 2, 2, 956, 957, 3, 2, 2, 2, 957, 963, 3, 2, 2, 2, 958, 956,
	3, 2, 2, 2, 959, 960, 7, 4, 2, 2, 960, 962, 5, 108, 55, 2, 961, 959, 3,
	2, 2, 2, 962, 965, 3, 2, 2, 2, 963, 961, 3, 2, 2, 2, 963, 964, 3, 2, 2,
	2, 964, 967, 3, 2, 2, 2, 965, 963, 3, 2, 2, 2, 966, 951, 3, 2, 2, 2, 966,
	967, 3, 2, 2, 2, 967, 968, 3, 2, 2, 2, 968, 969, 7, 6, 2, 2, 969, 980,
	3, 2, 2, 2, 970, 980, 5, 106, 54, 2, 971, 972, 5, 106, 54, 2, 972, 973,
	7, 7, 2, 2, 973, 974, 5, 106, 54, 2, 974, 980, 3, 2, 2, 2, 975, 976, 7,
	5, 2, 2, 976, 977, 5, 78, 40, 2, 977, 978, 7, 6, 2, 2, 978, 980, 3, 2,
	2, 2, 979, 858, 3, 2, 2, 2, 979, 860, 3, 2, 2, 2, 979, 863, 3, 2, 2, 2,
	979, 876, 3, 2, 2, 2, 979, 888, 3, 2, 2, 2, 979, 895, 3, 2, 2, 2, 979,
	908, 3, 2, 2, 2, 979, 926, 3, 2, 2, 2, 979, 944, 3, 2, 2, 2, 979, 949,
	3, 2, 2, 2, 979, 970, 3, 2, 2, 2, 979, 971, 3, 2, 2, 2, 979, 975, 3, 2,
	2, 2, 980, 991, 3, 2, 2, 2, 981, 982, 12, 7, 2, 2, 982, 983, 7, 8, 2, 2,
	983, 984, 5, 86, 44, 2, 984, 985, 7, 9, 2, 2, 985, 990, 3, 2, 2, 2, 986,
	987, 12, 4, 2, 2, 987, 988, 7, 159, 2, 2, 988, 990, 5, 106, 54, 2, 989,
	981, 3, 2, 2, 2, 989, 986, 3, 2, 2, 2, 990, 993, 3, 2, 2, 2, 991, 989,
	3, 2, 2, 2, 991, 992, 3, 2, 2, 2, 992, 89, 3, 2, 2, 2, 993, 991, 3, 2,
	2, 2, 994, 997, 5, 78, 40, 2, 995, 997, 5, 48, 25, 2, 996, 994, 3, 2, 2,
	2, 996, 995, 3, 2, 2, 2, 997, 91, 3, 2, 2, 2, 998, 999, 7, 41, 2, 2, 999,
	1000, 7, 58, 2, 2, 1000, 1001, 7, 161, 2, 2, 1001, 93, 3, 2, 2, 2, 1002,
	1003, 9, 10, 2, 2, 1003, 95, 3, 2, 2, 2, 1004, 1005, 9, 11, 2, 2, 1005,
	97, 3, 2, 2, 2, 1006, 1007, 8, 50, 1, 2, 1007, 1008, 7, 114, 2, 2, 1008,
	1009, 7, 148, 2, 2, 1009, 1010, 5, 98, 50, 2, 1010, 1011, 7, 150, 2, 2,
	1011, 1057, 3, 2, 2, 2, 1012, 1013, 7, 115, 2, 2, 1013, 1014, 7, 148, 2,
	2, 1014, 1015, 5, 98, 50, 2, 1015, 1016, 7, 4, 2, 2, 1016, 1017, 5, 98,
	50, 2, 1017, 1018, 7, 150, 2, 2, 1018, 1057, 3, 2, 2, 2, 1019, 1020, 7,
	79, 2, 2, 1020, 1032, 7, 148, 2, 2, 1021, 1022, 5, 106, 54, 2, 1022, 1029,
	5, 98, 50, 2, 1023, 1024, 7, 4, 2, 2, 1024, 1025, 5, 106, 54, 2, 1025,
	1026, 5, 98, 50, 2, 1026, 1028, 3, 2, 2, 2, 1027, 1023, 3, 2, 2, 2, 1028,
	1031, 3, 2, 2, 2, 1029, 1027, 3, 2, 2, 2, 1029, 1030, 3, 2, 2, 2, 1030,
	1033, 3, 2, 2, 2, 1031, 1029, 3, 2, 2, 2, 1032, 1021, 3, 2, 2, 2, 1032,
	1033, 3, 2, 2, 2, 1033, 1034, 3, 2, 2, 2, 1034, 1057, 7, 150, 2, 2, 1035,
	1036, 7, 129, 2, 2, 1036, 1037, 7, 5, 2, 2, 1037, 1038, 5, 116, 59, 2,
	1038, 1039, 7, 4, 2, 2, 1039, 1040, 5, 116, 59, 2, 1040, 1041, 7, 6, 2,
	2, 1041, 1057, 3, 2, 2, 2, 1042, 1054, 5, 102, 52, 2, 1043, 1044, 7, 5,
	2, 2, 1044, 1049, 5, 100, 51, 2, 1045, 1046, 7, 4, 2, 2, 1046, 1048, 5,
	100, 51, 2, 1047, 1045, 3, 2, 2, 2, 1048, 1051, 3, 2, 2, 2, 1049, 1047,
	3, 2, 2, 2, 1049, 1050, 3, 2, 2, 2, 1050, 1052, 3, 2, 2, 2, 1051, 1049,
	3, 2, 2, 2, 1052, 1053, 7, 6, 2, 2, 1053, 1055, 3, 2, 2, 2, 1054, 1043,
	3, 2, 2, 2, 1054, 1055, 3, 2, 2, 2, 1055, 1057, 3, 2, 2, 2, 1056, 1006,
	3, 2, 2, 2, 1056, 1012, 3, 2, 2, 2, 1056, 1019, 3, 2, 2, 2, 1056, 1035,
	3, 2, 2, 2, 1056, 1042, 3, 2, 2, 2, 1057, 1062, 3, 2, 2, 2, 1058, 1059,
	12, 8, 2, 2, 1059, 1061, 7, 114, 2, 2, 1060, 1058, 3, 2, 2, 2, 1061, 1064,
	3, 2, 2, 2, 1062, 1060, 3, 2, 2, 2, 1062, 1063, 3, 2, 2, 2, 1063, 99, 3,
	2, 2, 2, 1064, 1062, 3, 2, 2, 2, 1065, 1066, 9, 12, 2, 2, 1066, 101, 3,
	2, 2, 2, 1067, 1068, 5, 106, 54, 2, 1068, 103, 3, 2, 2, 2, 1069, 1070,
	7, 67, 2, 2, 1070, 1071, 5, 78, 40, 2, 1071, 1072, 7, 68, 2, 2, 1072, 1073,
	5, 78, 40, 2, 1073, 105, 3, 2, 2, 2, 1074, 1081, 7, 169, 2, 2, 1075, 1081,
	7, 165, 2, 2, 1076, 1081, 7, 167, 2, 2, 1077, 1081, 5, 120, 61, 2, 1078,
	1081, 7, 168, 2, 2, 1079, 1081, 7, 166, 2, 2, 1080, 1074, 3, 2, 2, 2, 1080,
	1075, 3, 2, 2, 2, 1080, 1076, 3, 2, 2, 2, 1080, 1077, 3, 2, 2, 2, 1080,
	1078, 3, 2, 2, 2, 1080, 1079, 3, 2, 2, 2, 1081, 107, 3, 2, 2, 2, 1082,
	1083, 5, 106, 54, 2, 1083, 1084, 7, 160, 2, 2, 1084, 1085, 5, 78, 40, 2,
	1085, 1100, 3, 2, 2, 2, 1086, 1087, 7, 5, 2, 2, 1087, 1092, 5, 106, 54,
	2, 1088, 1089, 7, 4, 2, 2, 1089, 1091, 5, 106, 54, 2, 1090, 1088, 3, 2,
	2, 2, 1091, 1094, 3, 2, 2, 2, 1092, 1090, 3, 2, 2, 2, 1092, 1093, 3, 2,
	2, 2, 1093, 1095, 3, 2, 2, 2, 1094, 1092, 3, 2, 2, 2, 1095, 1096, 7, 6,
	2, 2, 1096, 1097, 7, 160, 2, 2, 1097, 1098, 5, 78, 40, 2, 1098, 1100, 3,
	2, 2, 2, 1099, 1082, 3, 2, 2, 2, 1099, 1086, 3, 2, 2, 2, 1100, 109, 3,
	2, 2, 2, 1101, 1102, 7, 165, 2, 2, 1102, 111, 3, 2, 2, 2, 1103, 1104, 7,
	161, 2, 2, 1104, 113, 3, 2, 2, 2, 1105, 1106, 5, 106, 54, 2, 1106, 115,
	3, 2, 2, 2, 1107, 1109, 7, 153, 2, 2, 1108, 1107, 3, 2, 2, 2, 1108, 1109,
	3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 1120, 7, 163, 2, 2, 1111, 1113,
	7, 153, 2, 2, 1112, 1111, 3, 2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 1114,
	3, 2, 2, 2, 1114, 1120, 7, 164, 2, 2, 1115, 1117, 7, 153, 2, 2, 1116, 1115,
	3, 2, 2, 2, 1116, 1117, 3, 2, 2, 2, 1117, 1118, 3, 2, 2, 2, 1118, 1120,
	7, 162, 2, 2, 1119, 1108, 3, 2, 2, 2, 1119, 1112, 3, 2, 2, 2, 1119, 1116,
	3, 2, 2, 2, 1120, 117, 3, 2, 2, 2, 1121, 1127, 7, 36, 2, 2, 1122, 1127,
	5, 116, 59, 2, 1123, 1127, 5, 96, 49, 2, 1124, 1127, 7, 161, 2, 2, 1125,
	1127, 7, 169, 2, 2, 1126, 1121, 3, 2, 2, 2, 1126, 1122, 3, 2, 2, 2, 1126,
	1123, 3, 2, 2, 2, 1126, 1124, 3, 2, 2, 2, 1126, 1125, 3, 2, 2, 2, 1127,
	119, 3, 2, 2, 2, 1128, 1129, 9, 13, 2, 2, 1129, 121, 3, 2, 2, 2, 147, 125,
	137, 140, 153, 157, 162, 167, 173, 186, 191, 202, 208, 230, 233, 239, 243,
	247, 252, 258, 263, 271, 274, 280, 284, 288, 293, 299, 304, 315, 326, 334,
	343, 348, 354, 359, 365, 371, 378, 388, 399, 402, 408, 418, 427, 431, 437,
	441, 443, 455, 462, 466, 471, 476, 480, 484, 487, 493, 504, 512, 515, 523,
	530, 537, 540, 543, 561, 566, 575, 579, 595, 599, 609, 613, 624, 633, 636,
	639, 646, 655, 658, 661, 669, 672, 678, 681, 688, 694, 697, 703, 708, 712,
	716, 718, 729, 733, 735, 745, 748, 756, 769, 777, 779, 784, 790, 798, 807,
	813, 819, 823, 828, 833, 839, 853, 855, 868, 872, 880, 884, 902, 905, 920,
	923, 938, 941, 956, 963, 966, 979, 989, 991, 996, 1029, 1032, 1049, 1054,
	1056, 1062, 1080, 1092, 1099, 1108, 1112, 1116, 1119, 1126,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "';'", "','", "'('", "')'", "'.'", "'['", "']'", "'STRING'", "'EMIT'",
	"'CHANGES'", "'FINAL'", "'SELECT'", "'FROM'", "'AS'", "'ALL'", "'DISTINCT'",
	"'WHERE'", "'WITHIN'", "'WINDOW'", "'GROUP'", "'BY'", "'HAVING'", "'LIMIT'",
	"'AT'", "'OR'", "'AND'", "'IN'", "'NOT'", "'EXISTS'", "'BETWEEN'", "'LIKE'",
	"'ESCAPE'", "'IS'", "'NULL'", "'TRUE'", "'FALSE'", "'INTEGER'", "'DATE'",
	"'TIME'", "'TIMESTAMP'", "'INTERVAL'", "'YEAR'", "'MONTH'", "'DAY'", "'HOUR'",
	"'MINUTE'", "'SECOND'", "'MILLISECOND'", "'YEARS'", "'MONTHS'", "'DAYS'",
	"'HOURS'", "'MINUTES'", "'SECONDS'", "'MILLISECONDS'", "'ZONE'", "'TUMBLING'",
	"'HOPPING'", "'SIZE'", "'ADVANCE'", "'RETENTION'", "'GRACE'", "'PERIOD'",
	"'CASE'", "'WHEN'", "'THEN'", "'ELSE'", "'END'", "'JOIN'", "'FULL'", "'OUTER'",
	"'INNER'", "'LEFT'", "'RIGHT'", "'ON'", "'PARTITION'", "'STRUCT'", "'WITH'",
	"'VALUES'", "'CREATE'", "'TABLE'", "'TOPIC'", "'STREAM'", "'STREAMS'",
	"'INSERT'", "'DELETE'", "'INTO'", "'DESCRIBE'", "'EXTENDED'", "'PRINT'",
	"'EXPLAIN'", "'ANALYZE'", "'TYPE'", "'TYPES'", "'CAST'", "'SHOW'", "'LIST'",
	"'TABLES'", "'TOPICS'", "'QUERY'", "'QUERIES'", "'TERMINATE'", "'LOAD'",
	"'COLUMNS'", "'COLUMN'", "'PARTITIONS'", "'FUNCTIONS'", "'FUNCTION'", "'DROP'",
	"'TO'", "'RENAME'", "'ARRAY'", "'MAP'", "'SET'", "'DEFINE'", "'UNDEFINE'",
	"'RESET'", "'SESSION'", "'SAMPLE'", "'EXPORT'", "'CATALOG'", "'PROPERTIES'",
	"'BEGINNING'", "'UNSET'", "'RUN'", "'SCRIPT'", "'DECIMAL'", "'KEY'", "'CONNECTOR'",
	"'CONNECTORS'", "'SINK'", "'SOURCE'", "'NAMESPACE'", "'MATERIALIZED'",
	"'VIEW'", "'PRIMARY'", "'REPLACE'", "'ASSERT'", "'ADD'", "'ALTER'", "'VARIABLES'",
	"'PLUGINS'", "'IF'", "'='", "", "'<'", "'<='", "'>'", "'>='", "'+'", "'-'",
	"'*'", "'/'", "'%'", "'||'", "':='", "'->'", "'=>'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "EMIT", "CHANGES", "FINAL", "SELECT",
	"FROM", "AS", "ALL", "DISTINCT", "WHERE", "WITHIN", "WINDOW", "GROUP",
	"BY", "HAVING", "LIMIT", "AT", "OR", "AND", "IN", "NOT", "EXISTS", "BETWEEN",
	"LIKE", "ESCAPE", "IS", "NULL", "TRUE", "FALSE", "INTEGER", "DATE", "TIME",
	"TIMESTAMP", "INTERVAL", "YEAR", "MONTH", "DAY", "HOUR", "MINUTE", "SECOND",
	"MILLISECOND", "YEARS", "MONTHS", "DAYS", "HOURS", "MINUTES", "SECONDS",
	"MILLISECONDS", "ZONE", "TUMBLING", "HOPPING", "SIZE", "ADVANCE", "RETENTION",
	"GRACE", "PERIOD", "CASE", "WHEN", "THEN", "ELSE", "END", "JOIN", "FULL",
	"OUTER", "INNER", "LEFT", "RIGHT", "ON", "PARTITION", "STRUCT", "WITH",
	"VALUES", "CREATE", "TABLE", "TOPIC", "STREAM", "STREAMS", "INSERT", "DELETE",
	"INTO", "DESCRIBE", "EXTENDED", "PRINT", "EXPLAIN", "ANALYZE", "TYPE",
	"TYPES", "CAST", "SHOW", "LIST", "TABLES", "TOPICS", "QUERY", "QUERIES",
	"TERMINATE", "LOAD", "COLUMNS", "COLUMN", "PARTITIONS", "FUNCTIONS", "FUNCTION",
	"DROP", "TO", "RENAME", "ARRAY", "MAP", "SET", "DEFINE", "UNDEFINE", "RESET",
	"SESSION", "SAMPLE", "EXPORT", "CATALOG", "PROPERTIES", "BEGINNING", "UNSET",
	"RUN", "SCRIPT", "DECIMAL", "KEY", "CONNECTOR", "CONNECTORS", "SINK", "SOURCE",
	"NAMESPACE", "MATERIALIZED", "VIEW", "PRIMARY", "REPLACE", "ASSERT", "ADD",
	"ALTER", "VARIABLES", "PLUGINS", "IF", "EQ", "NEQ", "LT", "LTE", "GT",
	"GTE", "PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT", "CONCAT", "ASSIGN",
	"STRUCT_FIELD_REF", "LAMBDA_EXPRESSION", "STRING", "INTEGER_VALUE", "DECIMAL_VALUE",
	"FLOATING_POINT_VALUE", "IDENTIFIER", "DIGIT_IDENTIFIER", "QUOTED_IDENTIFIER",
	"BACKQUOTED_IDENTIFIER", "VARIABLE", "SIMPLE_COMMENT", "DIRECTIVE_COMMENT",
	"BRACKETED_COMMENT", "WS", "UNRECOGNIZED", "DELIMITER",
}

var ruleNames = []string{
	"statements", "testStatement", "singleStatement", "singleExpression", "statement",
	"assertStatement", "runScript", "query", "resultMaterialization", "alterOption",
	"tableElements", "tableElement", "tableProperties", "tableProperty", "printClause",
	"intervalClause", "limitClause", "retentionClause", "gracePeriodClause",
	"windowExpression", "tumblingWindowExpression", "hoppingWindowExpression",
	"sessionWindowExpression", "windowUnit", "groupBy", "partitionBy", "values",
	"selectItem", "relation", "joinedSource", "joinType", "joinWindow", "withinExpression",
	"joinWindowSize", "joinCriteria", "aliasedRelation", "columns", "relationPrimary",
	"expression", "booleanExpression", "predicated", "predicate", "valueExpression",
	"primaryExpression", "functionArgument", "timeZoneSpecifier", "comparisonOperator",
	"booleanValue", "sqltype", "typeParameter", "baseType", "whenClause", "identifier",
	"lambdaFunction", "variableName", "variableValue", "sourceName", "number",
	"literal", "nonReserved",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type KSqlParser struct {
	*antlr.BaseParser
}

func NewKSqlParser(input antlr.TokenStream) *KSqlParser {
	this := new(KSqlParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "KSql.g4"

	return this
}

// KSqlParser tokens.
const (
	KSqlParserEOF                   = antlr.TokenEOF
	KSqlParserT__0                  = 1
	KSqlParserT__1                  = 2
	KSqlParserT__2                  = 3
	KSqlParserT__3                  = 4
	KSqlParserT__4                  = 5
	KSqlParserT__5                  = 6
	KSqlParserT__6                  = 7
	KSqlParserT__7                  = 8
	KSqlParserEMIT                  = 9
	KSqlParserCHANGES               = 10
	KSqlParserFINAL                 = 11
	KSqlParserSELECT                = 12
	KSqlParserFROM                  = 13
	KSqlParserAS                    = 14
	KSqlParserALL                   = 15
	KSqlParserDISTINCT              = 16
	KSqlParserWHERE                 = 17
	KSqlParserWITHIN                = 18
	KSqlParserWINDOW                = 19
	KSqlParserGROUP                 = 20
	KSqlParserBY                    = 21
	KSqlParserHAVING                = 22
	KSqlParserLIMIT                 = 23
	KSqlParserAT                    = 24
	KSqlParserOR                    = 25
	KSqlParserAND                   = 26
	KSqlParserIN                    = 27
	KSqlParserNOT                   = 28
	KSqlParserEXISTS                = 29
	KSqlParserBETWEEN               = 30
	KSqlParserLIKE                  = 31
	KSqlParserESCAPE                = 32
	KSqlParserIS                    = 33
	KSqlParserNULL                  = 34
	KSqlParserTRUE                  = 35
	KSqlParserFALSE                 = 36
	KSqlParserINTEGER               = 37
	KSqlParserDATE                  = 38
	KSqlParserTIME                  = 39
	KSqlParserTIMESTAMP             = 40
	KSqlParserINTERVAL              = 41
	KSqlParserYEAR                  = 42
	KSqlParserMONTH                 = 43
	KSqlParserDAY                   = 44
	KSqlParserHOUR                  = 45
	KSqlParserMINUTE                = 46
	KSqlParserSECOND                = 47
	KSqlParserMILLISECOND           = 48
	KSqlParserYEARS                 = 49
	KSqlParserMONTHS                = 50
	KSqlParserDAYS                  = 51
	KSqlParserHOURS                 = 52
	KSqlParserMINUTES               = 53
	KSqlParserSECONDS               = 54
	KSqlParserMILLISECONDS          = 55
	KSqlParserZONE                  = 56
	KSqlParserTUMBLING              = 57
	KSqlParserHOPPING               = 58
	KSqlParserSIZE                  = 59
	KSqlParserADVANCE               = 60
	KSqlParserRETENTION             = 61
	KSqlParserGRACE                 = 62
	KSqlParserPERIOD                = 63
	KSqlParserCASE                  = 64
	KSqlParserWHEN                  = 65
	KSqlParserTHEN                  = 66
	KSqlParserELSE                  = 67
	KSqlParserEND                   = 68
	KSqlParserJOIN                  = 69
	KSqlParserFULL                  = 70
	KSqlParserOUTER                 = 71
	KSqlParserINNER                 = 72
	KSqlParserLEFT                  = 73
	KSqlParserRIGHT                 = 74
	KSqlParserON                    = 75
	KSqlParserPARTITION             = 76
	KSqlParserSTRUCT                = 77
	KSqlParserWITH                  = 78
	KSqlParserVALUES                = 79
	KSqlParserCREATE                = 80
	KSqlParserTABLE                 = 81
	KSqlParserTOPIC                 = 82
	KSqlParserSTREAM                = 83
	KSqlParserSTREAMS               = 84
	KSqlParserINSERT                = 85
	KSqlParserDELETE                = 86
	KSqlParserINTO                  = 87
	KSqlParserDESCRIBE              = 88
	KSqlParserEXTENDED              = 89
	KSqlParserPRINT                 = 90
	KSqlParserEXPLAIN               = 91
	KSqlParserANALYZE               = 92
	KSqlParserTYPE                  = 93
	KSqlParserTYPES                 = 94
	KSqlParserCAST                  = 95
	KSqlParserSHOW                  = 96
	KSqlParserLIST                  = 97
	KSqlParserTABLES                = 98
	KSqlParserTOPICS                = 99
	KSqlParserQUERY                 = 100
	KSqlParserQUERIES               = 101
	KSqlParserTERMINATE             = 102
	KSqlParserLOAD                  = 103
	KSqlParserCOLUMNS               = 104
	KSqlParserCOLUMN                = 105
	KSqlParserPARTITIONS            = 106
	KSqlParserFUNCTIONS             = 107
	KSqlParserFUNCTION              = 108
	KSqlParserDROP                  = 109
	KSqlParserTO                    = 110
	KSqlParserRENAME                = 111
	KSqlParserARRAY                 = 112
	KSqlParserMAP                   = 113
	KSqlParserSET                   = 114
	KSqlParserDEFINE                = 115
	KSqlParserUNDEFINE              = 116
	KSqlParserRESET                 = 117
	KSqlParserSESSION               = 118
	KSqlParserSAMPLE                = 119
	KSqlParserEXPORT                = 120
	KSqlParserCATALOG               = 121
	KSqlParserPROPERTIES            = 122
	KSqlParserBEGINNING             = 123
	KSqlParserUNSET                 = 124
	KSqlParserRUN                   = 125
	KSqlParserSCRIPT                = 126
	KSqlParserDECIMAL               = 127
	KSqlParserKEY                   = 128
	KSqlParserCONNECTOR             = 129
	KSqlParserCONNECTORS            = 130
	KSqlParserSINK                  = 131
	KSqlParserSOURCE                = 132
	KSqlParserNAMESPACE             = 133
	KSqlParserMATERIALIZED          = 134
	KSqlParserVIEW                  = 135
	KSqlParserPRIMARY               = 136
	KSqlParserREPLACE               = 137
	KSqlParserASSERT                = 138
	KSqlParserADD                   = 139
	KSqlParserALTER                 = 140
	KSqlParserVARIABLES             = 141
	KSqlParserPLUGINS               = 142
	KSqlParserIF                    = 143
	KSqlParserEQ                    = 144
	KSqlParserNEQ                   = 145
	KSqlParserLT                    = 146
	KSqlParserLTE                   = 147
	KSqlParserGT                    = 148
	KSqlParserGTE                   = 149
	KSqlParserPLUS                  = 150
	KSqlParserMINUS                 = 151
	KSqlParserASTERISK              = 152
	KSqlParserSLASH                 = 153
	KSqlParserPERCENT               = 154
	KSqlParserCONCAT                = 155
	KSqlParserASSIGN                = 156
	KSqlParserSTRUCT_FIELD_REF      = 157
	KSqlParserLAMBDA_EXPRESSION     = 158
	KSqlParserSTRING                = 159
	KSqlParserINTEGER_VALUE         = 160
	KSqlParserDECIMAL_VALUE         = 161
	KSqlParserFLOATING_POINT_VALUE  = 162
	KSqlParserIDENTIFIER            = 163
	KSqlParserDIGIT_IDENTIFIER      = 164
	KSqlParserQUOTED_IDENTIFIER     = 165
	KSqlParserBACKQUOTED_IDENTIFIER = 166
	KSqlParserVARIABLE              = 167
	KSqlParserSIMPLE_COMMENT        = 168
	KSqlParserDIRECTIVE_COMMENT     = 169
	KSqlParserBRACKETED_COMMENT     = 170
	KSqlParserWS                    = 171
	KSqlParserUNRECOGNIZED          = 172
	KSqlParserDELIMITER             = 173
)

// KSqlParser rules.
const (
	KSqlParserRULE_statements               = 0
	KSqlParserRULE_testStatement            = 1
	KSqlParserRULE_singleStatement          = 2
	KSqlParserRULE_singleExpression         = 3
	KSqlParserRULE_statement                = 4
	KSqlParserRULE_assertStatement          = 5
	KSqlParserRULE_runScript                = 6
	KSqlParserRULE_query                    = 7
	KSqlParserRULE_resultMaterialization    = 8
	KSqlParserRULE_alterOption              = 9
	KSqlParserRULE_tableElements            = 10
	KSqlParserRULE_tableElement             = 11
	KSqlParserRULE_tableProperties          = 12
	KSqlParserRULE_tableProperty            = 13
	KSqlParserRULE_printClause              = 14
	KSqlParserRULE_intervalClause           = 15
	KSqlParserRULE_limitClause              = 16
	KSqlParserRULE_retentionClause          = 17
	KSqlParserRULE_gracePeriodClause        = 18
	KSqlParserRULE_windowExpression         = 19
	KSqlParserRULE_tumblingWindowExpression = 20
	KSqlParserRULE_hoppingWindowExpression  = 21
	KSqlParserRULE_sessionWindowExpression  = 22
	KSqlParserRULE_windowUnit               = 23
	KSqlParserRULE_groupBy                  = 24
	KSqlParserRULE_partitionBy              = 25
	KSqlParserRULE_values                   = 26
	KSqlParserRULE_selectItem               = 27
	KSqlParserRULE_relation                 = 28
	KSqlParserRULE_joinedSource             = 29
	KSqlParserRULE_joinType                 = 30
	KSqlParserRULE_joinWindow               = 31
	KSqlParserRULE_withinExpression         = 32
	KSqlParserRULE_joinWindowSize           = 33
	KSqlParserRULE_joinCriteria             = 34
	KSqlParserRULE_aliasedRelation          = 35
	KSqlParserRULE_columns                  = 36
	KSqlParserRULE_relationPrimary          = 37
	KSqlParserRULE_expression               = 38
	KSqlParserRULE_booleanExpression        = 39
	KSqlParserRULE_predicated               = 40
	KSqlParserRULE_predicate                = 41
	KSqlParserRULE_valueExpression          = 42
	KSqlParserRULE_primaryExpression        = 43
	KSqlParserRULE_functionArgument         = 44
	KSqlParserRULE_timeZoneSpecifier        = 45
	KSqlParserRULE_comparisonOperator       = 46
	KSqlParserRULE_booleanValue             = 47
	KSqlParserRULE_sqltype                  = 48
	KSqlParserRULE_typeParameter            = 49
	KSqlParserRULE_baseType                 = 50
	KSqlParserRULE_whenClause               = 51
	KSqlParserRULE_identifier               = 52
	KSqlParserRULE_lambdaFunction           = 53
	KSqlParserRULE_variableName             = 54
	KSqlParserRULE_variableValue            = 55
	KSqlParserRULE_sourceName               = 56
	KSqlParserRULE_number                   = 57
	KSqlParserRULE_literal                  = 58
	KSqlParserRULE_nonReserved              = 59
)

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *StatementsContext) AllSingleStatement() []ISingleStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleStatementContext)(nil)).Elem())
	var tst = make([]ISingleStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleStatementContext)
		}
	}

	return tst
}

func (s *StatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *KSqlParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KSqlParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserSELECT || (((_la-80)&-(0x1f+1)) == 0 && ((1<<uint((_la-80)))&((1<<(KSqlParserCREATE-80))|(1<<(KSqlParserINSERT-80))|(1<<(KSqlParserDESCRIBE-80))|(1<<(KSqlParserPRINT-80))|(1<<(KSqlParserEXPLAIN-80))|(1<<(KSqlParserSHOW-80))|(1<<(KSqlParserLIST-80))|(1<<(KSqlParserTERMINATE-80))|(1<<(KSqlParserDROP-80)))) != 0) || (((_la-114)&-(0x1f+1)) == 0 && ((1<<uint((_la-114)))&((1<<(KSqlParserSET-114))|(1<<(KSqlParserDEFINE-114))|(1<<(KSqlParserUNDEFINE-114))|(1<<(KSqlParserUNSET-114))|(1<<(KSqlParserALTER-114)))) != 0) {
		{
			p.SetState(120)
			p.SingleStatement()
		}

		p.SetState(125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(126)
		p.Match(KSqlParserEOF)
	}

	return localctx
}

// ITestStatementContext is an interface to support dynamic dispatch.
type ITestStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestStatementContext differentiates from other interfaces.
	IsTestStatementContext()
}

type TestStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestStatementContext() *TestStatementContext {
	var p = new(TestStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_testStatement
	return p
}

func (*TestStatementContext) IsTestStatementContext() {}

func NewTestStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestStatementContext {
	var p = new(TestStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_testStatement

	return p
}

func (s *TestStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TestStatementContext) SingleStatement() ISingleStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *TestStatementContext) AssertStatement() IAssertStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *TestStatementContext) RunScript() IRunScriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRunScriptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRunScriptContext)
}

func (s *TestStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *TestStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTestStatement(s)
	}
}

func (s *TestStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTestStatement(s)
	}
}

func (p *KSqlParser) TestStatement() (localctx ITestStatementContext) {
	localctx = NewTestStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KSqlParserRULE_testStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(135)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserSELECT, KSqlParserCREATE, KSqlParserINSERT, KSqlParserDESCRIBE, KSqlParserPRINT, KSqlParserEXPLAIN, KSqlParserSHOW, KSqlParserLIST, KSqlParserTERMINATE, KSqlParserDROP, KSqlParserSET, KSqlParserDEFINE, KSqlParserUNDEFINE, KSqlParserUNSET, KSqlParserALTER:
		{
			p.SetState(128)
			p.SingleStatement()
		}

	case KSqlParserASSERT:
		{
			p.SetState(129)
			p.AssertStatement()
		}
		{
			p.SetState(130)
			p.Match(KSqlParserT__0)
		}

	case KSqlParserRUN:
		{
			p.SetState(132)
			p.RunScript()
		}
		{
			p.SetState(133)
			p.Match(KSqlParserT__0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(138)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(137)
			p.Match(KSqlParserEOF)
		}

	}

	return localctx
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_singleStatement
	return p
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *KSqlParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KSqlParserRULE_singleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(140)
		p.Statement()
	}
	{
		p.SetState(141)
		p.Match(KSqlParserT__0)
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleExpression(s)
	}
}

func (s *SingleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleExpression(s)
	}
}

func (p *KSqlParser) SingleExpression() (localctx ISingleExpressionContext) {
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KSqlParserRULE_singleExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(143)
		p.Expression()
	}
	{
		p.SetState(144)
		p.Match(KSqlParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ListTablesContext struct {
	*StatementContext
}

func NewListTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTablesContext {
	var p = new(ListTablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLES, 0)
}

func (s *ListTablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTablesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTables(s)
	}
}

func (s *ListTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTables(s)
	}
}

type DefineVariableContext struct {
	*StatementContext
}

func NewDefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefineVariableContext {
	var p = new(DefineVariableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineVariableContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDEFINE, 0)
}

func (s *DefineVariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *DefineVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *DefineVariableContext) VariableValue() IVariableValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableValueContext)
}

func (s *DefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDefineVariable(s)
	}
}

func (s *DefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDefineVariable(s)
	}
}

type ExplainContext struct {
	*StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitExplain(s)
	}
}

type CreateTableContext struct {
	*StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *CreateTableContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateTableContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateTableContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateTableContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type UnsetPropertyContext struct {
	*StatementContext
}

func NewUnsetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsetPropertyContext {
	var p = new(UnsetPropertyContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UnsetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetPropertyContext) UNSET() antlr.TerminalNode {
	return s.GetToken(KSqlParserUNSET, 0)
}

func (s *UnsetPropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *UnsetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUnsetProperty(s)
	}
}

func (s *UnsetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUnsetProperty(s)
	}
}

type ListTypesContext struct {
	*StatementContext
}

func NewListTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTypesContext {
	var p = new(ListTypesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypesContext) TYPES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPES, 0)
}

func (s *ListTypesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTypesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTypes(s)
	}
}

func (s *ListTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTypes(s)
	}
}

type DescribeFunctionContext struct {
	*StatementContext
}

func NewDescribeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeFunctionContext {
	var p = new(DescribeFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeFunctionContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTION, 0)
}

func (s *DescribeFunctionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeFunction(s)
	}
}

func (s *DescribeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeFunction(s)
	}
}

type RegisterTypeContext struct {
	*StatementContext
}

func NewRegisterTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegisterTypeContext {
	var p = new(RegisterTypeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RegisterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegisterTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *RegisterTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *RegisterTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RegisterTypeContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *RegisterTypeContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *RegisterTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *RegisterTypeContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *RegisterTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *RegisterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRegisterType(s)
	}
}

func (s *RegisterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRegisterType(s)
	}
}

type ListTopicsContext struct {
	*StatementContext
}

func NewListTopicsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTopicsContext {
	var p = new(ListTopicsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTopicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTopicsContext) TOPICS() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPICS, 0)
}

func (s *ListTopicsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTopicsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTopicsContext) ALL() antlr.TerminalNode {
	return s.GetToken(KSqlParserALL, 0)
}

func (s *ListTopicsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListTopicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTopics(s)
	}
}

func (s *ListTopicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTopics(s)
	}
}

type ListQueriesContext struct {
	*StatementContext
}

func NewListQueriesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListQueriesContext {
	var p = new(ListQueriesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListQueriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListQueriesContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(KSqlParserQUERIES, 0)
}

func (s *ListQueriesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListQueriesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListQueriesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListQueriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListQueries(s)
	}
}

func (s *ListQueriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListQueries(s)
	}
}

type DropStreamContext struct {
	*StatementContext
}

func NewDropStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStreamContext {
	var p = new(DropStreamContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStreamContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *DropStreamContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropStreamContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDELETE, 0)
}

func (s *DropStreamContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPIC, 0)
}

func (s *DropStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropStream(s)
	}
}

func (s *DropStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropStream(s)
	}
}

type QueryStatementContext struct {
	*StatementContext
}

func NewQueryStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryStatementContext {
	var p = new(QueryStatementContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

type CreateStreamAsContext struct {
	*StatementContext
}

func NewCreateStreamAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamAsContext {
	var p = new(CreateStreamAsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateStreamAsContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *CreateStreamAsContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamAsContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CreateStreamAsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateStreamAsContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateStreamAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateStreamAsContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateStreamAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateStreamAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateStreamAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateStreamAsContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateStreamAs(s)
	}
}

func (s *CreateStreamAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateStreamAs(s)
	}
}

type CreateTableAsContext struct {
	*StatementContext
}

func NewCreateTableAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsContext {
	var p = new(CreateTableAsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateTableAsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *CreateTableAsContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableAsContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CreateTableAsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateTableAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateTableAsContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateTableAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateTableAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateTableAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateTableAsContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateTableAs(s)
	}
}

func (s *CreateTableAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateTableAs(s)
	}
}

type CreateConnectorContext struct {
	*StatementContext
}

func NewCreateConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateConnectorContext {
	var p = new(CreateConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateConnectorContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *CreateConnectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateConnectorContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateConnectorContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateConnectorContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *CreateConnectorContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateConnectorContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateConnector(s)
	}
}

func (s *CreateConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateConnector(s)
	}
}

type CreateStreamContext struct {
	*StatementContext
}

func NewCreateStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamContext {
	var p = new(CreateStreamContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *CreateStreamContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateStreamContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateStreamContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateStreamContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateStreamContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateStreamContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateStream(s)
	}
}

func (s *CreateStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateStream(s)
	}
}

type ListConnectorsContext struct {
	*StatementContext
}

func NewListConnectorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorsContext {
	var p = new(ListConnectorsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorsContext) CONNECTORS() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTORS, 0)
}

func (s *ListConnectorsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListConnectorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListConnectorsContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *ListConnectorsContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *ListConnectorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListConnectors(s)
	}
}

func (s *ListConnectorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListConnectors(s)
	}
}

type ListVariablesContext struct {
	*StatementContext
}

func NewListVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListVariablesContext {
	var p = new(ListVariablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListVariablesContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLES, 0)
}

func (s *ListVariablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListVariablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListVariables(s)
	}
}

func (s *ListVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListVariables(s)
	}
}

type ListStreamsContext struct {
	*StatementContext
}

func NewListStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListStreamsContext {
	var p = new(ListStreamsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAMS, 0)
}

func (s *ListStreamsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListStreamsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListStreams(s)
	}
}

func (s *ListStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListStreams(s)
	}
}

type ShowColumnsContext struct {
	*StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *ShowColumnsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type DropTableContext struct {
	*StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *DropTableContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropTableContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDELETE, 0)
}

func (s *DropTableContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPIC, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type DropConnectorContext struct {
	*StatementContext
}

func NewDropConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConnectorContext {
	var p = new(DropConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConnectorContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *DropConnectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropConnector(s)
	}
}

func (s *DropConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropConnector(s)
	}
}

type ListConnectorPluginsContext struct {
	*StatementContext
}

func NewListConnectorPluginsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorPluginsContext {
	var p = new(ListConnectorPluginsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorPluginsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorPluginsContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *ListConnectorPluginsContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUGINS, 0)
}

func (s *ListConnectorPluginsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListConnectorPluginsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListConnectorPluginsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListConnectorPlugins(s)
	}
}

func (s *ListConnectorPluginsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListConnectorPlugins(s)
	}
}

type ListFunctionsContext struct {
	*StatementContext
}

func NewListFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListFunctionsContext {
	var p = new(ListFunctionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTIONS, 0)
}

func (s *ListFunctionsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListFunctions(s)
	}
}

func (s *ListFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListFunctions(s)
	}
}

type DescribeConnectorContext struct {
	*StatementContext
}

func NewDescribeConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectorContext {
	var p = new(DescribeConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectorContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *DescribeConnectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeConnector(s)
	}
}

func (s *DescribeConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeConnector(s)
	}
}

type InsertIntoContext struct {
	*StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTO, 0)
}

func (s *InsertIntoContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *InsertIntoContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

type AlterSourceContext struct {
	*StatementContext
}

func NewAlterSourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSourceContext {
	var p = new(AlterSourceContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AlterSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserALTER, 0)
}

func (s *AlterSourceContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AlterSourceContext) AllAlterOption() []IAlterOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterOptionContext)(nil)).Elem())
	var tst = make([]IAlterOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterOptionContext)
		}
	}

	return tst
}

func (s *AlterSourceContext) AlterOption(i int) IAlterOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterOptionContext)
}

func (s *AlterSourceContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *AlterSourceContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *AlterSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAlterSource(s)
	}
}

func (s *AlterSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAlterSource(s)
	}
}

type PrintTopicContext struct {
	*StatementContext
}

func NewPrintTopicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrintTopicContext {
	var p = new(PrintTopicContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *PrintTopicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintTopicContext) PRINT() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRINT, 0)
}

func (s *PrintTopicContext) PrintClause() IPrintClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrintClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrintClauseContext)
}

func (s *PrintTopicContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrintTopicContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *PrintTopicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPrintTopic(s)
	}
}

func (s *PrintTopicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPrintTopic(s)
	}
}

type ListPropertiesContext struct {
	*StatementContext
}

func NewListPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPropertiesContext {
	var p = new(ListPropertiesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(KSqlParserPROPERTIES, 0)
}

func (s *ListPropertiesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListProperties(s)
	}
}

func (s *ListPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListProperties(s)
	}
}

type DropTypeContext struct {
	*StatementContext
}

func NewDropTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTypeContext {
	var p = new(DropTypeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *DropTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropType(s)
	}
}

func (s *DropTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropType(s)
	}
}

type SetPropertyContext struct {
	*StatementContext
}

func NewSetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPropertyContext {
	var p = new(SetPropertyContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPropertyContext) SET() antlr.TerminalNode {
	return s.GetToken(KSqlParserSET, 0)
}

func (s *SetPropertyContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserSTRING)
}

func (s *SetPropertyContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, i)
}

func (s *SetPropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *SetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSetProperty(s)
	}
}

func (s *SetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSetProperty(s)
	}
}

type TerminateQueryContext struct {
	*StatementContext
}

func NewTerminateQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TerminateQueryContext {
	var p = new(TerminateQueryContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *TerminateQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminateQueryContext) TERMINATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTERMINATE, 0)
}

func (s *TerminateQueryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TerminateQueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(KSqlParserALL, 0)
}

func (s *TerminateQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTerminateQuery(s)
	}
}

func (s *TerminateQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTerminateQuery(s)
	}
}

type UndefineVariableContext struct {
	*StatementContext
}

func NewUndefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UndefineVariableContext {
	var p = new(UndefineVariableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UndefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndefineVariableContext) UNDEFINE() antlr.TerminalNode {
	return s.GetToken(KSqlParserUNDEFINE, 0)
}

func (s *UndefineVariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *UndefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUndefineVariable(s)
	}
}

func (s *UndefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUndefineVariable(s)
	}
}

type InsertValuesContext struct {
	*StatementContext
}

func NewInsertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertValuesContext {
	var p = new(InsertValuesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserINSERT, 0)
}

func (s *InsertValuesContext) INTO() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTO, 0)
}

func (s *InsertValuesContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertValuesContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, 0)
}

func (s *InsertValuesContext) Values() IValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *InsertValuesContext) Columns() IColumnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *InsertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInsertValues(s)
	}
}

func (s *InsertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInsertValues(s)
	}
}

type DescribeStreamsContext struct {
	*StatementContext
}

func NewDescribeStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStreamsContext {
	var p = new(DescribeStreamsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStreamsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAMS, 0)
}

func (s *DescribeStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *DescribeStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeStreams(s)
	}
}

func (s *DescribeStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeStreams(s)
	}
}

func (p *KSqlParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KSqlParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQueryStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(146)
			p.Query()
		}

	case 2:
		localctx = NewListPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(147)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(148)
			p.Match(KSqlParserPROPERTIES)
		}

	case 3:
		localctx = NewListTopicsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(149)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(151)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserALL {
			{
				p.SetState(150)
				p.Match(KSqlParserALL)
			}

		}
		{
			p.SetState(153)
			p.Match(KSqlParserTOPICS)
		}
		p.SetState(155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(154)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 4:
		localctx = NewListStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(157)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(158)
			p.Match(KSqlParserSTREAMS)
		}
		p.SetState(160)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(159)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 5:
		localctx = NewListTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(162)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(163)
			p.Match(KSqlParserTABLES)
		}
		p.SetState(165)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(164)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 6:
		localctx = NewListFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(167)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(168)
			p.Match(KSqlParserFUNCTIONS)
		}

	case 7:
		localctx = NewListConnectorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(169)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSINK || _la == KSqlParserSOURCE {
			{
				p.SetState(170)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KSqlParserSINK || _la == KSqlParserSOURCE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(173)
			p.Match(KSqlParserCONNECTORS)
		}

	case 8:
		localctx = NewListConnectorPluginsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(174)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(175)
			p.Match(KSqlParserCONNECTOR)
		}
		{
			p.SetState(176)
			p.Match(KSqlParserPLUGINS)
		}

	case 9:
		localctx = NewListTypesContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(177)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(178)
			p.Match(KSqlParserTYPES)
		}

	case 10:
		localctx = NewListVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(179)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(180)
			p.Match(KSqlParserVARIABLES)
		}

	case 11:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(181)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(182)
			p.SourceName()
		}
		p.SetState(184)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(183)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 12:
		localctx = NewDescribeStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(186)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(187)
			p.Match(KSqlParserSTREAMS)
		}
		p.SetState(189)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(188)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 13:
		localctx = NewDescribeFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(191)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(192)
			p.Match(KSqlParserFUNCTION)
		}
		{
			p.SetState(193)
			p.Identifier()
		}

	case 14:
		localctx = NewDescribeConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(194)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(195)
			p.Match(KSqlParserCONNECTOR)
		}
		{
			p.SetState(196)
			p.Identifier()
		}

	case 15:
		localctx = NewPrintTopicContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(197)
			p.Match(KSqlParserPRINT)
		}
		p.SetState(200)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
			{
				p.SetState(198)
				p.Identifier()
			}

		case KSqlParserSTRING:
			{
				p.SetState(199)
				p.Match(KSqlParserSTRING)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(202)
			p.PrintClause()
		}

	case 16:
		localctx = NewListQueriesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(203)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(204)
			p.Match(KSqlParserQUERIES)
		}
		p.SetState(206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(205)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 17:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(208)
			p.Match(KSqlParserTERMINATE)
		}
		{
			p.SetState(209)
			p.Identifier()
		}

	case 18:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(210)
			p.Match(KSqlParserTERMINATE)
		}
		{
			p.SetState(211)
			p.Match(KSqlParserALL)
		}

	case 19:
		localctx = NewSetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(212)
			p.Match(KSqlParserSET)
		}
		{
			p.SetState(213)
			p.Match(KSqlParserSTRING)
		}
		{
			p.SetState(214)
			p.Match(KSqlParserEQ)
		}
		{
			p.SetState(215)
			p.Match(KSqlParserSTRING)
		}

	case 20:
		localctx = NewUnsetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(216)
			p.Match(KSqlParserUNSET)
		}
		{
			p.SetState(217)
			p.Match(KSqlParserSTRING)
		}

	case 21:
		localctx = NewDefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(218)
			p.Match(KSqlParserDEFINE)
		}
		{
			p.SetState(219)
			p.VariableName()
		}
		{
			p.SetState(220)
			p.Match(KSqlParserEQ)
		}
		{
			p.SetState(221)
			p.VariableValue()
		}

	case 22:
		localctx = NewUndefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(223)
			p.Match(KSqlParserUNDEFINE)
		}
		{
			p.SetState(224)
			p.VariableName()
		}

	case 23:
		localctx = NewCreateStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(225)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(226)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(227)
				p.Match(KSqlParserREPLACE)
			}

		}
		p.SetState(231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSOURCE {
			{
				p.SetState(230)
				p.Match(KSqlParserSOURCE)
			}

		}
		{
			p.SetState(233)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(237)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(234)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(235)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(236)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(239)
			p.SourceName()
		}
		p.SetState(241)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(240)
				p.TableElements()
			}

		}
		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(243)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(244)
				p.TableProperties()
			}

		}

	case 24:
		localctx = NewCreateStreamAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(247)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(248)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(249)
				p.Match(KSqlParserREPLACE)
			}

		}
		{
			p.SetState(252)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(253)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(254)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(255)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(258)
			p.SourceName()
		}
		p.SetState(261)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(259)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(260)
				p.TableProperties()
			}

		}
		{
			p.SetState(263)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(264)
			p.Query()
		}

	case 25:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(266)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(267)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(268)
				p.Match(KSqlParserREPLACE)
			}

		}
		p.SetState(272)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSOURCE {
			{
				p.SetState(271)
				p.Match(KSqlParserSOURCE)
			}

		}
		{
			p.SetState(274)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(275)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(276)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(277)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(280)
			p.SourceName()
		}
		p.SetState(282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(281)
				p.TableElements()
			}

		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(284)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(285)
				p.TableProperties()
			}

		}

	case 26:
		localctx = NewCreateTableAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(288)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(289)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(290)
				p.Match(KSqlParserREPLACE)
			}

		}
		{
			p.SetState(293)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(294)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(295)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(296)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(299)
			p.SourceName()
		}
		p.SetState(302)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(300)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(301)
				p.TableProperties()
			}

		}
		{
			p.SetState(304)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(305)
			p.Query()
		}

	case 27:
		localctx = NewCreateConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(307)
			p.Match(KSqlParserCREATE)
		}
		{
			p.SetState(308)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSINK || _la == KSqlParserSOURCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(309)
			p.Match(KSqlParserCONNECTOR)
		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(310)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(311)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(312)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(315)
			p.Identifier()
		}
		{
			p.SetState(316)
			p.Match(KSqlParserWITH)
		}
		{
			p.SetState(317)
			p.TableProperties()
		}

	case 28:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(319)
			p.Match(KSqlParserINSERT)
		}
		{
			p.SetState(320)
			p.Match(KSqlParserINTO)
		}
		{
			p.SetState(321)
			p.SourceName()
		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(322)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(323)
				p.TableProperties()
			}

		}
		{
			p.SetState(326)
			p.Query()
		}

	case 29:
		localctx = NewInsertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(328)
			p.Match(KSqlParserINSERT)
		}
		{
			p.SetState(329)
			p.Match(KSqlParserINTO)
		}
		{
			p.SetState(330)
			p.SourceName()
		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(331)
				p.Columns()
			}

		}
		{
			p.SetState(334)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(335)
			p.Values()
		}

	case 30:
		localctx = NewDropStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(337)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(338)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(339)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(340)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(343)
			p.SourceName()
		}
		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserDELETE {
			{
				p.SetState(344)
				p.Match(KSqlParserDELETE)
			}
			{
				p.SetState(345)
				p.Match(KSqlParserTOPIC)
			}

		}

	case 31:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(348)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(349)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(350)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(351)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(354)
			p.SourceName()
		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserDELETE {
			{
				p.SetState(355)
				p.Match(KSqlParserDELETE)
			}
			{
				p.SetState(356)
				p.Match(KSqlParserTOPIC)
			}

		}

	case 32:
		localctx = NewDropConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(359)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(360)
			p.Match(KSqlParserCONNECTOR)
		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(361)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(362)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(365)
			p.Identifier()
		}

	case 33:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(366)
			p.Match(KSqlParserEXPLAIN)
		}
		p.SetState(369)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(367)
				p.Statement()
			}

		case 2:
			{
				p.SetState(368)
				p.Identifier()
			}

		}

	case 34:
		localctx = NewRegisterTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(371)
			p.Match(KSqlParserCREATE)
		}
		{
			p.SetState(372)
			p.Match(KSqlParserTYPE)
		}
		p.SetState(376)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(373)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(374)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(375)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(378)
			p.Identifier()
		}
		{
			p.SetState(379)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(380)
			p.sqltype(0)
		}

	case 35:
		localctx = NewDropTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(382)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(383)
			p.Match(KSqlParserTYPE)
		}
		p.SetState(386)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(384)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(385)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(388)
			p.Identifier()
		}

	case 36:
		localctx = NewAlterSourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(389)
			p.Match(KSqlParserALTER)
		}
		{
			p.SetState(390)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserTABLE || _la == KSqlParserSTREAM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(391)
			p.SourceName()
		}
		{
			p.SetState(392)
			p.AlterOption()
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(393)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(394)
				p.AlterOption()
			}

			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_assertStatement
	return p
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) CopyFrom(ctx *AssertStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AssertValuesContext struct {
	*AssertStatementContext
}

func NewAssertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertValuesContext {
	var p = new(AssertValuesContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertValuesContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertValuesContext) AllVALUES() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserVALUES)
}

func (s *AssertValuesContext) VALUES(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, i)
}

func (s *AssertValuesContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertValuesContext) Values() IValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertValuesContext) Columns() IColumnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertValues(s)
	}
}

func (s *AssertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertValues(s)
	}
}

type AssertTombstoneContext struct {
	*AssertStatementContext
}

func NewAssertTombstoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTombstoneContext {
	var p = new(AssertTombstoneContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTombstoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTombstoneContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertTombstoneContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *AssertTombstoneContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, 0)
}

func (s *AssertTombstoneContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTombstoneContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *AssertTombstoneContext) Values() IValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertTombstoneContext) Columns() IColumnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertTombstoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertTombstone(s)
	}
}

func (s *AssertTombstoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertTombstone(s)
	}
}

type AssertTableContext struct {
	*AssertStatementContext
}

func NewAssertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTableContext {
	var p = new(AssertTableContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTableContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *AssertTableContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTableContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *AssertTableContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertTable(s)
	}
}

func (s *AssertTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertTable(s)
	}
}

type AssertStreamContext struct {
	*AssertStatementContext
}

func NewAssertStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertStreamContext {
	var p = new(AssertStreamContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStreamContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *AssertStreamContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertStreamContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *AssertStreamContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertStream(s)
	}
}

func (s *AssertStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertStream(s)
	}
}

func (p *KSqlParser) AssertStatement() (localctx IAssertStatementContext) {
	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KSqlParserRULE_assertStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAssertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(402)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(403)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(404)
			p.SourceName()
		}
		p.SetState(406)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(405)
				p.Columns()
			}

		}
		{
			p.SetState(408)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(409)
			p.Values()
		}

	case 2:
		localctx = NewAssertTombstoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(411)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(412)
			p.Match(KSqlParserNULL)
		}
		{
			p.SetState(413)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(414)
			p.SourceName()
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(415)
				p.Columns()
			}

		}
		{
			p.SetState(418)
			p.Match(KSqlParserKEY)
		}
		{
			p.SetState(419)
			p.Values()
		}

	case 3:
		localctx = NewAssertStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(421)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(422)
			p.Match(KSqlParserSTREAM)
		}
		{
			p.SetState(423)
			p.SourceName()
		}
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(424)
				p.TableElements()
			}

		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(427)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(428)
				p.TableProperties()
			}

		}

	case 4:
		localctx = NewAssertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(431)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(432)
			p.Match(KSqlParserTABLE)
		}
		{
			p.SetState(433)
			p.SourceName()
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(434)
				p.TableElements()
			}

		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(437)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(438)
				p.TableProperties()
			}

		}

	}

	return localctx
}

// IRunScriptContext is an interface to support dynamic dispatch.
type IRunScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRunScriptContext differentiates from other interfaces.
	IsRunScriptContext()
}

type RunScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRunScriptContext() *RunScriptContext {
	var p = new(RunScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_runScript
	return p
}

func (*RunScriptContext) IsRunScriptContext() {}

func NewRunScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RunScriptContext {
	var p = new(RunScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_runScript

	return p
}

func (s *RunScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *RunScriptContext) RUN() antlr.TerminalNode {
	return s.GetToken(KSqlParserRUN, 0)
}

func (s *RunScriptContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSCRIPT, 0)
}

func (s *RunScriptContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *RunScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RunScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RunScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRunScript(s)
	}
}

func (s *RunScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRunScript(s)
	}
}

func (p *KSqlParser) RunScript() (localctx IRunScriptContext) {
	localctx = NewRunScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KSqlParserRULE_runScript)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)
		p.Match(KSqlParserRUN)
	}
	{
		p.SetState(444)
		p.Match(KSqlParserSCRIPT)
	}
	{
		p.SetState(445)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IRelationContext

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetFrom sets the from rule contexts.
	SetFrom(IRelationContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IRelationContext
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) GetFrom() IRelationContext { return s.from }

func (s *QueryContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QueryContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QueryContext) SetFrom(v IRelationContext) { s.from = v }

func (s *QueryContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QueryContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSELECT, 0)
}

func (s *QueryContext) AllSelectItem() []ISelectItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectItemContext)(nil)).Elem())
	var tst = make([]ISelectItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectItemContext)
		}
	}

	return tst
}

func (s *QueryContext) SelectItem(i int) ISelectItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *QueryContext) Relation() IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QueryContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserWINDOW, 0)
}

func (s *QueryContext) WindowExpression() IWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowExpressionContext)
}

func (s *QueryContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KSqlParserWHERE, 0)
}

func (s *QueryContext) GROUP() antlr.TerminalNode {
	return s.GetToken(KSqlParserGROUP, 0)
}

func (s *QueryContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserBY)
}

func (s *QueryContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserBY, i)
}

func (s *QueryContext) GroupBy() IGroupByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QueryContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITION, 0)
}

func (s *QueryContext) PartitionBy() IPartitionByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionByContext)
}

func (s *QueryContext) HAVING() antlr.TerminalNode {
	return s.GetToken(KSqlParserHAVING, 0)
}

func (s *QueryContext) EMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserEMIT, 0)
}

func (s *QueryContext) ResultMaterialization() IResultMaterializationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResultMaterializationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResultMaterializationContext)
}

func (s *QueryContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *QueryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *KSqlParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KSqlParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(KSqlParserSELECT)
	}
	{
		p.SetState(448)
		p.SelectItem()
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(449)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(450)
			p.SelectItem()
		}

		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(456)
		p.Match(KSqlParserFROM)
	}
	{
		p.SetState(457)

		var _x = p.Relation()

		localctx.(*QueryContext).from = _x
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWINDOW {
		{
			p.SetState(458)
			p.Match(KSqlParserWINDOW)
		}
		{
			p.SetState(459)
			p.WindowExpression()
		}

	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWHERE {
		{
			p.SetState(462)
			p.Match(KSqlParserWHERE)
		}
		{
			p.SetState(463)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).where = _x
		}

	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserGROUP {
		{
			p.SetState(466)
			p.Match(KSqlParserGROUP)
		}
		{
			p.SetState(467)
			p.Match(KSqlParserBY)
		}
		{
			p.SetState(468)
			p.GroupBy()
		}

	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserPARTITION {
		{
			p.SetState(471)
			p.Match(KSqlParserPARTITION)
		}
		{
			p.SetState(472)
			p.Match(KSqlParserBY)
		}
		{
			p.SetState(473)
			p.PartitionBy()
		}

	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserHAVING {
		{
			p.SetState(476)
			p.Match(KSqlParserHAVING)
		}
		{
			p.SetState(477)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).having = _x
		}

	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserEMIT {
		{
			p.SetState(480)
			p.Match(KSqlParserEMIT)
		}
		{
			p.SetState(481)
			p.ResultMaterialization()
		}

	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserLIMIT {
		{
			p.SetState(484)
			p.LimitClause()
		}

	}

	return localctx
}

// IResultMaterializationContext is an interface to support dynamic dispatch.
type IResultMaterializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResultMaterializationContext differentiates from other interfaces.
	IsResultMaterializationContext()
}

type ResultMaterializationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultMaterializationContext() *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_resultMaterialization
	return p
}

func (*ResultMaterializationContext) IsResultMaterializationContext() {}

func NewResultMaterializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_resultMaterialization

	return p
}

func (s *ResultMaterializationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultMaterializationContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(KSqlParserCHANGES, 0)
}

func (s *ResultMaterializationContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFINAL, 0)
}

func (s *ResultMaterializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultMaterializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultMaterializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterResultMaterialization(s)
	}
}

func (s *ResultMaterializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitResultMaterialization(s)
	}
}

func (p *KSqlParser) ResultMaterialization() (localctx IResultMaterializationContext) {
	localctx = NewResultMaterializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KSqlParserRULE_resultMaterialization)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserCHANGES || _la == KSqlParserFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAlterOptionContext is an interface to support dynamic dispatch.
type IAlterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterOptionContext differentiates from other interfaces.
	IsAlterOptionContext()
}

type AlterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterOptionContext() *AlterOptionContext {
	var p = new(AlterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_alterOption
	return p
}

func (*AlterOptionContext) IsAlterOptionContext() {}

func NewAlterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterOptionContext {
	var p = new(AlterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_alterOption

	return p
}

func (s *AlterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterOptionContext) ADD() antlr.TerminalNode {
	return s.GetToken(KSqlParserADD, 0)
}

func (s *AlterOptionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterOptionContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *AlterOptionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMN, 0)
}

func (s *AlterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAlterOption(s)
	}
}

func (s *AlterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAlterOption(s)
	}
}

func (p *KSqlParser) AlterOption() (localctx IAlterOptionContext) {
	localctx = NewAlterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KSqlParserRULE_alterOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(KSqlParserADD)
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(490)
			p.Match(KSqlParserCOLUMN)
		}

	}
	{
		p.SetState(493)
		p.Identifier()
	}
	{
		p.SetState(494)
		p.sqltype(0)
	}

	return localctx
}

// ITableElementsContext is an interface to support dynamic dispatch.
type ITableElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementsContext differentiates from other interfaces.
	IsTableElementsContext()
}

type TableElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementsContext() *TableElementsContext {
	var p = new(TableElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableElements
	return p
}

func (*TableElementsContext) IsTableElementsContext() {}

func NewTableElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementsContext {
	var p = new(TableElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableElements

	return p
}

func (s *TableElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementsContext) AllTableElement() []ITableElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableElementContext)(nil)).Elem())
	var tst = make([]ITableElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableElementContext)
		}
	}

	return tst
}

func (s *TableElementsContext) TableElement(i int) ITableElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *TableElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableElements(s)
	}
}

func (s *TableElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableElements(s)
	}
}

func (p *KSqlParser) TableElements() (localctx ITableElementsContext) {
	localctx = NewTableElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KSqlParserRULE_tableElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(497)
		p.TableElement()
	}
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(498)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(499)
			p.TableElement()
		}

		p.SetState(504)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(505)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableElement
	return p
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableElementContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *TableElementContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *TableElementContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRIMARY, 0)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *KSqlParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KSqlParserRULE_tableElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.Identifier()
	}
	{
		p.SetState(508)
		p.sqltype(0)
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserKEY || _la == KSqlParserPRIMARY {
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserPRIMARY {
			{
				p.SetState(509)
				p.Match(KSqlParserPRIMARY)
			}

		}
		{
			p.SetState(512)
			p.Match(KSqlParserKEY)
		}

	}

	return localctx
}

// ITablePropertiesContext is an interface to support dynamic dispatch.
type ITablePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablePropertiesContext differentiates from other interfaces.
	IsTablePropertiesContext()
}

type TablePropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesContext() *TablePropertiesContext {
	var p = new(TablePropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableProperties
	return p
}

func (*TablePropertiesContext) IsTablePropertiesContext() {}

func NewTablePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesContext {
	var p = new(TablePropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableProperties

	return p
}

func (s *TablePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesContext) AllTableProperty() []ITablePropertyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITablePropertyContext)(nil)).Elem())
	var tst = make([]ITablePropertyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITablePropertyContext)
		}
	}

	return tst
}

func (s *TablePropertiesContext) TableProperty(i int) ITablePropertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *TablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableProperties(s)
	}
}

func (s *TablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableProperties(s)
	}
}

func (p *KSqlParser) TableProperties() (localctx ITablePropertiesContext) {
	localctx = NewTablePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KSqlParserRULE_tableProperties)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(516)
		p.TableProperty()
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(517)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(518)
			p.TableProperty()
		}

		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(524)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ITablePropertyContext is an interface to support dynamic dispatch.
type ITablePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablePropertyContext differentiates from other interfaces.
	IsTablePropertyContext()
}

type TablePropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyContext() *TablePropertyContext {
	var p = new(TablePropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableProperty
	return p
}

func (*TablePropertyContext) IsTablePropertyContext() {}

func NewTablePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyContext {
	var p = new(TablePropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableProperty

	return p
}

func (s *TablePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *TablePropertyContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TablePropertyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TablePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableProperty(s)
	}
}

func (s *TablePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableProperty(s)
	}
}

func (p *KSqlParser) TableProperty() (localctx ITablePropertyContext) {
	localctx = NewTablePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KSqlParserRULE_tableProperty)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(528)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		{
			p.SetState(526)
			p.Identifier()
		}

	case KSqlParserSTRING:
		{
			p.SetState(527)
			p.Match(KSqlParserSTRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(530)
		p.Match(KSqlParserEQ)
	}
	{
		p.SetState(531)
		p.Literal()
	}

	return localctx
}

// IPrintClauseContext is an interface to support dynamic dispatch.
type IPrintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrintClauseContext differentiates from other interfaces.
	IsPrintClauseContext()
}

type PrintClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintClauseContext() *PrintClauseContext {
	var p = new(PrintClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_printClause
	return p
}

func (*PrintClauseContext) IsPrintClauseContext() {}

func NewPrintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintClauseContext {
	var p = new(PrintClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_printClause

	return p
}

func (s *PrintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *PrintClauseContext) BEGINNING() antlr.TerminalNode {
	return s.GetToken(KSqlParserBEGINNING, 0)
}

func (s *PrintClauseContext) IntervalClause() IIntervalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalClauseContext)
}

func (s *PrintClauseContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *PrintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPrintClause(s)
	}
}

func (s *PrintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPrintClause(s)
	}
}

func (p *KSqlParser) PrintClause() (localctx IPrintClauseContext) {
	localctx = NewPrintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KSqlParserRULE_printClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserFROM {
		{
			p.SetState(533)
			p.Match(KSqlParserFROM)
		}
		{
			p.SetState(534)
			p.Match(KSqlParserBEGINNING)
		}

	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserINTERVAL || _la == KSqlParserSAMPLE {
		{
			p.SetState(537)
			p.IntervalClause()
		}

	}
	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserLIMIT {
		{
			p.SetState(540)
			p.LimitClause()
		}

	}

	return localctx
}

// IIntervalClauseContext is an interface to support dynamic dispatch.
type IIntervalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalClauseContext differentiates from other interfaces.
	IsIntervalClauseContext()
}

type IntervalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalClauseContext() *IntervalClauseContext {
	var p = new(IntervalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_intervalClause
	return p
}

func (*IntervalClauseContext) IsIntervalClauseContext() {}

func NewIntervalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalClauseContext {
	var p = new(IntervalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_intervalClause

	return p
}

func (s *IntervalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *IntervalClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTERVAL, 0)
}

func (s *IntervalClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSAMPLE, 0)
}

func (s *IntervalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterIntervalClause(s)
	}
}

func (s *IntervalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitIntervalClause(s)
	}
}

func (p *KSqlParser) IntervalClause() (localctx IIntervalClauseContext) {
	localctx = NewIntervalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KSqlParserRULE_intervalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserINTERVAL || _la == KSqlParserSAMPLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(544)
		p.Number()
	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIMIT, 0)
}

func (s *LimitClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *KSqlParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KSqlParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.Match(KSqlParserLIMIT)
	}
	{
		p.SetState(547)
		p.Number()
	}

	return localctx
}

// IRetentionClauseContext is an interface to support dynamic dispatch.
type IRetentionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRetentionClauseContext differentiates from other interfaces.
	IsRetentionClauseContext()
}

type RetentionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetentionClauseContext() *RetentionClauseContext {
	var p = new(RetentionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_retentionClause
	return p
}

func (*RetentionClauseContext) IsRetentionClauseContext() {}

func NewRetentionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetentionClauseContext {
	var p = new(RetentionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_retentionClause

	return p
}

func (s *RetentionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RetentionClauseContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserRETENTION, 0)
}

func (s *RetentionClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RetentionClauseContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *RetentionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetentionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetentionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRetentionClause(s)
	}
}

func (s *RetentionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRetentionClause(s)
	}
}

func (p *KSqlParser) RetentionClause() (localctx IRetentionClauseContext) {
	localctx = NewRetentionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KSqlParserRULE_retentionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(549)
		p.Match(KSqlParserRETENTION)
	}
	{
		p.SetState(550)
		p.Number()
	}
	{
		p.SetState(551)
		p.WindowUnit()
	}

	return localctx
}

// IGracePeriodClauseContext is an interface to support dynamic dispatch.
type IGracePeriodClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGracePeriodClauseContext differentiates from other interfaces.
	IsGracePeriodClauseContext()
}

type GracePeriodClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGracePeriodClauseContext() *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_gracePeriodClause
	return p
}

func (*GracePeriodClauseContext) IsGracePeriodClauseContext() {}

func NewGracePeriodClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_gracePeriodClause

	return p
}

func (s *GracePeriodClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GracePeriodClauseContext) GRACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserGRACE, 0)
}

func (s *GracePeriodClauseContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KSqlParserPERIOD, 0)
}

func (s *GracePeriodClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *GracePeriodClauseContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *GracePeriodClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GracePeriodClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GracePeriodClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterGracePeriodClause(s)
	}
}

func (s *GracePeriodClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitGracePeriodClause(s)
	}
}

func (p *KSqlParser) GracePeriodClause() (localctx IGracePeriodClauseContext) {
	localctx = NewGracePeriodClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KSqlParserRULE_gracePeriodClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(KSqlParserGRACE)
	}
	{
		p.SetState(554)
		p.Match(KSqlParserPERIOD)
	}
	{
		p.SetState(555)
		p.Number()
	}
	{
		p.SetState(556)
		p.WindowUnit()
	}

	return localctx
}

// IWindowExpressionContext is an interface to support dynamic dispatch.
type IWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowExpressionContext differentiates from other interfaces.
	IsWindowExpressionContext()
}

type WindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowExpressionContext() *WindowExpressionContext {
	var p = new(WindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_windowExpression
	return p
}

func (*WindowExpressionContext) IsWindowExpressionContext() {}

func NewWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowExpressionContext {
	var p = new(WindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_windowExpression

	return p
}

func (s *WindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowExpressionContext) TumblingWindowExpression() ITumblingWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITumblingWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITumblingWindowExpressionContext)
}

func (s *WindowExpressionContext) HoppingWindowExpression() IHoppingWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHoppingWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHoppingWindowExpressionContext)
}

func (s *WindowExpressionContext) SessionWindowExpression() ISessionWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISessionWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISessionWindowExpressionContext)
}

func (s *WindowExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *WindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWindowExpression(s)
	}
}

func (s *WindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWindowExpression(s)
	}
}

func (p *KSqlParser) WindowExpression() (localctx IWindowExpressionContext) {
	localctx = NewWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KSqlParserRULE_windowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserIDENTIFIER {
		{
			p.SetState(558)
			p.Match(KSqlParserIDENTIFIER)
		}

	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserTUMBLING:
		{
			p.SetState(561)
			p.TumblingWindowExpression()
		}

	case KSqlParserHOPPING:
		{
			p.SetState(562)
			p.HoppingWindowExpression()
		}

	case KSqlParserSESSION:
		{
			p.SetState(563)
			p.SessionWindowExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITumblingWindowExpressionContext is an interface to support dynamic dispatch.
type ITumblingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTumblingWindowExpressionContext differentiates from other interfaces.
	IsTumblingWindowExpressionContext()
}

type TumblingWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTumblingWindowExpressionContext() *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tumblingWindowExpression
	return p
}

func (*TumblingWindowExpressionContext) IsTumblingWindowExpressionContext() {}

func NewTumblingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tumblingWindowExpression

	return p
}

func (s *TumblingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TumblingWindowExpressionContext) TUMBLING() antlr.TerminalNode {
	return s.GetToken(KSqlParserTUMBLING, 0)
}

func (s *TumblingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSIZE, 0)
}

func (s *TumblingWindowExpressionContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TumblingWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *TumblingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRetentionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *TumblingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *TumblingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TumblingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TumblingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTumblingWindowExpression(s)
	}
}

func (s *TumblingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTumblingWindowExpression(s)
	}
}

func (p *KSqlParser) TumblingWindowExpression() (localctx ITumblingWindowExpressionContext) {
	localctx = NewTumblingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KSqlParserRULE_tumblingWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(KSqlParserTUMBLING)
	}
	{
		p.SetState(567)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(568)
		p.Match(KSqlParserSIZE)
	}
	{
		p.SetState(569)
		p.Number()
	}
	{
		p.SetState(570)
		p.WindowUnit()
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(571)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(572)
			p.RetentionClause()
		}

	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(575)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(576)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(579)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IHoppingWindowExpressionContext is an interface to support dynamic dispatch.
type IHoppingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHoppingWindowExpressionContext differentiates from other interfaces.
	IsHoppingWindowExpressionContext()
}

type HoppingWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHoppingWindowExpressionContext() *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_hoppingWindowExpression
	return p
}

func (*HoppingWindowExpressionContext) IsHoppingWindowExpressionContext() {}

func NewHoppingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_hoppingWindowExpression

	return p
}

func (s *HoppingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *HoppingWindowExpressionContext) HOPPING() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOPPING, 0)
}

func (s *HoppingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSIZE, 0)
}

func (s *HoppingWindowExpressionContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *HoppingWindowExpressionContext) AllWindowUnit() []IWindowUnitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem())
	var tst = make([]IWindowUnitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWindowUnitContext)
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) WindowUnit(i int) IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *HoppingWindowExpressionContext) ADVANCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserADVANCE, 0)
}

func (s *HoppingWindowExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(KSqlParserBY, 0)
}

func (s *HoppingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRetentionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *HoppingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *HoppingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HoppingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HoppingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterHoppingWindowExpression(s)
	}
}

func (s *HoppingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitHoppingWindowExpression(s)
	}
}

func (p *KSqlParser) HoppingWindowExpression() (localctx IHoppingWindowExpressionContext) {
	localctx = NewHoppingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KSqlParserRULE_hoppingWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(KSqlParserHOPPING)
	}
	{
		p.SetState(582)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(583)
		p.Match(KSqlParserSIZE)
	}
	{
		p.SetState(584)
		p.Number()
	}
	{
		p.SetState(585)
		p.WindowUnit()
	}
	{
		p.SetState(586)
		p.Match(KSqlParserT__1)
	}
	{
		p.SetState(587)
		p.Match(KSqlParserADVANCE)
	}
	{
		p.SetState(588)
		p.Match(KSqlParserBY)
	}
	{
		p.SetState(589)
		p.Number()
	}
	{
		p.SetState(590)
		p.WindowUnit()
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(591)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(592)
			p.RetentionClause()
		}

	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(595)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(596)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(599)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ISessionWindowExpressionContext is an interface to support dynamic dispatch.
type ISessionWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSessionWindowExpressionContext differentiates from other interfaces.
	IsSessionWindowExpressionContext()
}

type SessionWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionWindowExpressionContext() *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sessionWindowExpression
	return p
}

func (*SessionWindowExpressionContext) IsSessionWindowExpressionContext() {}

func NewSessionWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sessionWindowExpression

	return p
}

func (s *SessionWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionWindowExpressionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(KSqlParserSESSION, 0)
}

func (s *SessionWindowExpressionContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SessionWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *SessionWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRetentionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *SessionWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SessionWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSessionWindowExpression(s)
	}
}

func (s *SessionWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSessionWindowExpression(s)
	}
}

func (p *KSqlParser) SessionWindowExpression() (localctx ISessionWindowExpressionContext) {
	localctx = NewSessionWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KSqlParserRULE_sessionWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.Match(KSqlParserSESSION)
	}
	{
		p.SetState(602)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(603)
		p.Number()
	}
	{
		p.SetState(604)
		p.WindowUnit()
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(605)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(606)
			p.RetentionClause()
		}

	}
	p.SetState(611)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(609)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(610)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(613)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IWindowUnitContext is an interface to support dynamic dispatch.
type IWindowUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowUnitContext differentiates from other interfaces.
	IsWindowUnitContext()
}

type WindowUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowUnitContext() *WindowUnitContext {
	var p = new(WindowUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_windowUnit
	return p
}

func (*WindowUnitContext) IsWindowUnitContext() {}

func NewWindowUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowUnitContext {
	var p = new(WindowUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_windowUnit

	return p
}

func (s *WindowUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAY, 0)
}

func (s *WindowUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOUR, 0)
}

func (s *WindowUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTE, 0)
}

func (s *WindowUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECOND, 0)
}

func (s *WindowUnitContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserMILLISECOND, 0)
}

func (s *WindowUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAYS, 0)
}

func (s *WindowUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOURS, 0)
}

func (s *WindowUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTES, 0)
}

func (s *WindowUnitContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECONDS, 0)
}

func (s *WindowUnitContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMILLISECONDS, 0)
}

func (s *WindowUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWindowUnit(s)
	}
}

func (s *WindowUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWindowUnit(s)
	}
}

func (p *KSqlParser) WindowUnit() (localctx IWindowUnitContext) {
	localctx = NewWindowUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KSqlParserRULE_windowUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(KSqlParserDAY-44))|(1<<(KSqlParserHOUR-44))|(1<<(KSqlParserMINUTE-44))|(1<<(KSqlParserSECOND-44))|(1<<(KSqlParserMILLISECOND-44))|(1<<(KSqlParserDAYS-44))|(1<<(KSqlParserHOURS-44))|(1<<(KSqlParserMINUTES-44))|(1<<(KSqlParserSECONDS-44))|(1<<(KSqlParserMILLISECONDS-44)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *GroupByContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (p *KSqlParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KSqlParserRULE_groupBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(637)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(617)
			p.valueExpression(0)
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(618)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(619)
				p.valueExpression(0)
			}

			p.SetState(624)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(625)
			p.Match(KSqlParserT__2)
		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(626)
				p.valueExpression(0)
			}
			p.SetState(631)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(627)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(628)
					p.valueExpression(0)
				}

				p.SetState(633)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(636)
			p.Match(KSqlParserT__3)
		}

	}

	return localctx
}

// IPartitionByContext is an interface to support dynamic dispatch.
type IPartitionByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionByContext differentiates from other interfaces.
	IsPartitionByContext()
}

type PartitionByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByContext() *PartitionByContext {
	var p = new(PartitionByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_partitionBy
	return p
}

func (*PartitionByContext) IsPartitionByContext() {}

func NewPartitionByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByContext {
	var p = new(PartitionByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_partitionBy

	return p
}

func (s *PartitionByContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *PartitionByContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PartitionByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPartitionBy(s)
	}
}

func (s *PartitionByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPartitionBy(s)
	}
}

func (p *KSqlParser) PartitionBy() (localctx IPartitionByContext) {
	localctx = NewPartitionByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KSqlParserRULE_partitionBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(639)
			p.valueExpression(0)
		}
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(640)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(641)
				p.valueExpression(0)
			}

			p.SetState(646)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(647)
			p.Match(KSqlParserT__2)
		}
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(648)
				p.valueExpression(0)
			}
			p.SetState(653)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(649)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(650)
					p.valueExpression(0)
				}

				p.SetState(655)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(658)
			p.Match(KSqlParserT__3)
		}

	}

	return localctx
}

// IValuesContext is an interface to support dynamic dispatch.
type IValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuesContext differentiates from other interfaces.
	IsValuesContext()
}

type ValuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesContext() *ValuesContext {
	var p = new(ValuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_values
	return p
}

func (*ValuesContext) IsValuesContext() {}

func NewValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesContext {
	var p = new(ValuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_values

	return p
}

func (s *ValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ValuesContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterValues(s)
	}
}

func (s *ValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitValues(s)
	}
}

func (p *KSqlParser) Values() (localctx IValuesContext) {
	localctx = NewValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KSqlParserRULE_values)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Match(KSqlParserT__2)
	}
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
		{
			p.SetState(662)
			p.valueExpression(0)
		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(663)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(664)
				p.valueExpression(0)
			}

			p.SetState(669)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(672)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (p *KSqlParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KSqlParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(674)
			p.Expression()
		}
		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL)|(1<<KSqlParserAS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			p.SetState(676)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == KSqlParserAS {
				{
					p.SetState(675)
					p.Match(KSqlParserAS)
				}

			}
			{
				p.SetState(678)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.Identifier()
		}
		{
			p.SetState(682)
			p.Match(KSqlParserT__4)
		}
		{
			p.SetState(683)
			p.Match(KSqlParserASTERISK)
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(685)
			p.Match(KSqlParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left IAliasedRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IAliasedRelationContext { return s.left }

func (s *JoinRelationContext) SetLeft(v IAliasedRelationContext) { s.left = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinRelationContext) AllJoinedSource() []IJoinedSourceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinedSourceContext)(nil)).Elem())
	var tst = make([]IJoinedSourceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinedSourceContext)
		}
	}

	return tst
}

func (s *JoinRelationContext) JoinedSource(i int) IJoinedSourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinedSourceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinedSourceContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *KSqlParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KSqlParserRULE_relation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(688)

			var _x = p.AliasedRelation()

			localctx.(*JoinRelationContext).left = _x
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KSqlParserJOIN-69))|(1<<(KSqlParserFULL-69))|(1<<(KSqlParserINNER-69))|(1<<(KSqlParserLEFT-69)))) != 0) {
			{
				p.SetState(689)
				p.JoinedSource()
			}

			p.SetState(692)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewRelationDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(694)
			p.AliasedRelation()
		}

	}

	return localctx
}

// IJoinedSourceContext is an interface to support dynamic dispatch.
type IJoinedSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinedSourceContext differentiates from other interfaces.
	IsJoinedSourceContext()
}

type JoinedSourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedSourceContext() *JoinedSourceContext {
	var p = new(JoinedSourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinedSource
	return p
}

func (*JoinedSourceContext) IsJoinedSourceContext() {}

func NewJoinedSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedSourceContext {
	var p = new(JoinedSourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinedSource

	return p
}

func (s *JoinedSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedSourceContext) JoinType() IJoinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinedSourceContext) JOIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserJOIN, 0)
}

func (s *JoinedSourceContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinedSourceContext) JoinCriteria() IJoinCriteriaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinCriteriaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinedSourceContext) JoinWindow() IJoinWindowContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinWindowContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinWindowContext)
}

func (s *JoinedSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinedSource(s)
	}
}

func (s *JoinedSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinedSource(s)
	}
}

func (p *KSqlParser) JoinedSource() (localctx IJoinedSourceContext) {
	localctx = NewJoinedSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KSqlParserRULE_joinedSource)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.JoinType()
	}
	{
		p.SetState(698)
		p.Match(KSqlParserJOIN)
	}
	{
		p.SetState(699)
		p.AliasedRelation()
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWITHIN {
		{
			p.SetState(700)
			p.JoinWindow()
		}

	}
	{
		p.SetState(703)
		p.JoinCriteria()
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) CopyFrom(ctx *JoinTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InnerJoinContext struct {
	*JoinTypeContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(KSqlParserINNER, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

type LeftJoinContext struct {
	*JoinTypeContext
}

func NewLeftJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LeftJoinContext {
	var p = new(LeftJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *LeftJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLEFT, 0)
}

func (s *LeftJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserOUTER, 0)
}

func (s *LeftJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLeftJoin(s)
	}
}

func (s *LeftJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLeftJoin(s)
	}
}

type OuterJoinContext struct {
	*JoinTypeContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) FULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFULL, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserOUTER, 0)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (p *KSqlParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KSqlParserRULE_joinType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(716)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserJOIN, KSqlParserINNER:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserINNER {
			{
				p.SetState(705)
				p.Match(KSqlParserINNER)
			}

		}

	case KSqlParserFULL:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(708)
			p.Match(KSqlParserFULL)
		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOUTER {
			{
				p.SetState(709)
				p.Match(KSqlParserOUTER)
			}

		}

	case KSqlParserLEFT:
		localctx = NewLeftJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(712)
			p.Match(KSqlParserLEFT)
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOUTER {
			{
				p.SetState(713)
				p.Match(KSqlParserOUTER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinWindowContext is an interface to support dynamic dispatch.
type IJoinWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinWindowContext differentiates from other interfaces.
	IsJoinWindowContext()
}

type JoinWindowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowContext() *JoinWindowContext {
	var p = new(JoinWindowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinWindow
	return p
}

func (*JoinWindowContext) IsJoinWindowContext() {}

func NewJoinWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowContext {
	var p = new(JoinWindowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinWindow

	return p
}

func (s *JoinWindowContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITHIN, 0)
}

func (s *JoinWindowContext) WithinExpression() IWithinExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithinExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithinExpressionContext)
}

func (s *JoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindow(s)
	}
}

func (s *JoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindow(s)
	}
}

func (p *KSqlParser) JoinWindow() (localctx IJoinWindowContext) {
	localctx = NewJoinWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KSqlParserRULE_joinWindow)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Match(KSqlParserWITHIN)
	}
	{
		p.SetState(719)
		p.WithinExpression()
	}

	return localctx
}

// IWithinExpressionContext is an interface to support dynamic dispatch.
type IWithinExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithinExpressionContext differentiates from other interfaces.
	IsWithinExpressionContext()
}

type WithinExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithinExpressionContext() *WithinExpressionContext {
	var p = new(WithinExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_withinExpression
	return p
}

func (*WithinExpressionContext) IsWithinExpressionContext() {}

func NewWithinExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithinExpressionContext {
	var p = new(WithinExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_withinExpression

	return p
}

func (s *WithinExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithinExpressionContext) CopyFrom(ctx *WithinExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *WithinExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithinExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleJoinWindowContext struct {
	*WithinExpressionContext
}

func NewSingleJoinWindowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleJoinWindowContext {
	var p = new(SingleJoinWindowContext)

	p.WithinExpressionContext = NewEmptyWithinExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WithinExpressionContext))

	return p
}

func (s *SingleJoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleJoinWindowContext) JoinWindowSize() IJoinWindowSizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinWindowSizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *SingleJoinWindowContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SingleJoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleJoinWindow(s)
	}
}

func (s *SingleJoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleJoinWindow(s)
	}
}

type JoinWindowWithBeforeAndAfterContext struct {
	*WithinExpressionContext
}

func NewJoinWindowWithBeforeAndAfterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinWindowWithBeforeAndAfterContext {
	var p = new(JoinWindowWithBeforeAndAfterContext)

	p.WithinExpressionContext = NewEmptyWithinExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WithinExpressionContext))

	return p
}

func (s *JoinWindowWithBeforeAndAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowWithBeforeAndAfterContext) AllJoinWindowSize() []IJoinWindowSizeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinWindowSizeContext)(nil)).Elem())
	var tst = make([]IJoinWindowSizeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinWindowSizeContext)
		}
	}

	return tst
}

func (s *JoinWindowWithBeforeAndAfterContext) JoinWindowSize(i int) IJoinWindowSizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinWindowSizeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindowWithBeforeAndAfter(s)
	}
}

func (s *JoinWindowWithBeforeAndAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindowWithBeforeAndAfter(s)
	}
}

func (p *KSqlParser) WithinExpression() (localctx IWithinExpressionContext) {
	localctx = NewWithinExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KSqlParserRULE_withinExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(733)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__2:
		localctx = NewJoinWindowWithBeforeAndAfterContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(721)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(722)
			p.JoinWindowSize()
		}
		{
			p.SetState(723)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(724)
			p.JoinWindowSize()
		}
		{
			p.SetState(725)
			p.Match(KSqlParserT__3)
		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserGRACE {
			{
				p.SetState(726)
				p.GracePeriodClause()
			}

		}

	case KSqlParserMINUS, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE:
		localctx = NewSingleJoinWindowContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(729)
			p.JoinWindowSize()
		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserGRACE {
			{
				p.SetState(730)
				p.GracePeriodClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinWindowSizeContext is an interface to support dynamic dispatch.
type IJoinWindowSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinWindowSizeContext differentiates from other interfaces.
	IsJoinWindowSizeContext()
}

type JoinWindowSizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowSizeContext() *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinWindowSize
	return p
}

func (*JoinWindowSizeContext) IsJoinWindowSizeContext() {}

func NewJoinWindowSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinWindowSize

	return p
}

func (s *JoinWindowSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowSizeContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *JoinWindowSizeContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *JoinWindowSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindowSize(s)
	}
}

func (s *JoinWindowSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindowSize(s)
	}
}

func (p *KSqlParser) JoinWindowSize() (localctx IJoinWindowSizeContext) {
	localctx = NewJoinWindowSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KSqlParserRULE_joinWindowSize)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(735)
		p.Number()
	}
	{
		p.SetState(736)
		p.WindowUnit()
	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(KSqlParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *KSqlParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KSqlParserRULE_joinCriteria)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(KSqlParserON)
	}
	{
		p.SetState(739)
		p.booleanExpression(0)
	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (p *KSqlParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KSqlParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.RelationPrimary()
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserAS {
			{
				p.SetState(742)
				p.Match(KSqlParserAS)
			}

		}
		{
			p.SetState(745)
			p.SourceName()
		}

	}

	return localctx
}

// IColumnsContext is an interface to support dynamic dispatch.
type IColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnsContext differentiates from other interfaces.
	IsColumnsContext()
}

type ColumnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsContext() *ColumnsContext {
	var p = new(ColumnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_columns
	return p
}

func (*ColumnsContext) IsColumnsContext() {}

func NewColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsContext {
	var p = new(ColumnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_columns

	return p
}

func (s *ColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnsContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumns(s)
	}
}

func (s *ColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumns(s)
	}
}

func (p *KSqlParser) Columns() (localctx IColumnsContext) {
	localctx = NewColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KSqlParserRULE_columns)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(749)
		p.Identifier()
	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(750)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(751)
			p.Identifier()
		}

		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(757)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *KSqlParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KSqlParserRULE_relationPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTableNameContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.SourceName()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *KSqlParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KSqlParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.booleanExpression(0)
	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type BooleanDefaultContext struct {
	*BooleanExpressionContext
}

func NewBooleanDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanDefaultContext {
	var p = new(BooleanDefaultContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanDefaultContext) Predicated() IPredicatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicatedContext)
}

func (s *BooleanDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanDefault(s)
	}
}

func (s *BooleanDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanDefault(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(KSqlParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *KSqlParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *KSqlParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, KSqlParserRULE_booleanExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(767)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__2, KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserNULL, KSqlParserTRUE, KSqlParserFALSE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserCASE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserCAST, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserPLUS, KSqlParserMINUS, KSqlParserSTRING, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		localctx = NewBooleanDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(764)
			p.Predicated()
		}

	case KSqlParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(765)
			p.Match(KSqlParserNOT)
		}
		{
			p.SetState(766)
			p.booleanExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(775)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_booleanExpression)
				p.SetState(769)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(770)

					var _m = p.Match(KSqlParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(771)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_booleanExpression)
				p.SetState(772)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(773)

					var _m = p.Match(KSqlParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(774)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			}

		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicatedContext is an interface to support dynamic dispatch.
type IPredicatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// IsPredicatedContext differentiates from other interfaces.
	IsPredicatedContext()
}

type PredicatedContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicatedContext() *PredicatedContext {
	var p = new(PredicatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_predicated
	return p
}

func (*PredicatedContext) IsPredicatedContext() {}

func NewPredicatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicatedContext {
	var p = new(PredicatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_predicated

	return p
}

func (s *PredicatedContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (p *KSqlParser) Predicated() (localctx IPredicatedContext) {
	localctx = NewPredicatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, KSqlParserRULE_predicated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)

		var _x = p.valueExpression(0)

		localctx.(*PredicatedContext)._valueExpression = _x
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(781)
			p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
		}

	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitComparison(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  antlr.Token
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetEscape() antlr.Token { return s.escape }

func (s *LikeContext) SetEscape(v antlr.Token) { s.escape = v }

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIKE, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserESCAPE, 0)
}

func (s *LikeContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLike(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(KSqlParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(KSqlParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInList(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(KSqlParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(KSqlParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (p *KSqlParser) Predicate(value antlr.ParserRuleContext) (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 82, KSqlParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(784)
			p.ComparisonOperator()
		}
		{
			p.SetState(785)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(787)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(790)
			p.Match(KSqlParserBETWEEN)
		}
		{
			p.SetState(791)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(792)
			p.Match(KSqlParserAND)
		}
		{
			p.SetState(793)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 3:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(795)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(798)
			p.Match(KSqlParserIN)
		}
		{
			p.SetState(799)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(800)
			p.Expression()
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(801)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(802)
				p.Expression()
			}

			p.SetState(807)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(808)
			p.Match(KSqlParserT__3)
		}

	case 4:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(810)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(813)
			p.Match(KSqlParserLIKE)
		}
		{
			p.SetState(814)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(815)
				p.Match(KSqlParserESCAPE)
			}
			{
				p.SetState(816)

				var _m = p.Match(KSqlParserSTRING)

				localctx.(*LikeContext).escape = _m
			}

		}

	case 5:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(819)
			p.Match(KSqlParserIS)
		}
		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(820)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(823)
			p.Match(KSqlParserNULL)
		}

	case 6:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(824)
			p.Match(KSqlParserIS)
		}
		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(825)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(828)
			p.Match(KSqlParserDISTINCT)
		}
		{
			p.SetState(829)
			p.Match(KSqlParserFROM)
		}
		{
			p.SetState(830)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(KSqlParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(KSqlParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

type AtTimeZoneContext struct {
	*ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(KSqlParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeZoneSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (p *KSqlParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *KSqlParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 84
	p.EnterRecursionRule(localctx, 84, KSqlParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(834)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(835)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserPLUS || _la == KSqlParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(836)
			p.valueExpression(4)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(851)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(839)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(840)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-152)&-(0x1f+1)) == 0 && ((1<<uint((_la-152)))&((1<<(KSqlParserASTERISK-152))|(1<<(KSqlParserSLASH-152))|(1<<(KSqlParserPERCENT-152)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(841)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(842)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(843)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == KSqlParserPLUS || _la == KSqlParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(844)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(845)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(846)
					p.Match(KSqlParserCONCAT)
				}
				{
					p.SetState(847)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(848)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(849)
					p.Match(KSqlParserAT)
				}
				{
					p.SetState(850)
					p.TimeZoneSpecifier()
				}

			}

		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) STRUCT_FIELD_REF() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT_FIELD_REF, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDereference(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(KSqlParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type StructConstructorContext struct {
	*PrimaryExpressionContext
}

func NewStructConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructConstructorContext {
	var p = new(StructConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StructConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructConstructorContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *StructConstructorContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *StructConstructorContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserASSIGN)
}

func (s *StructConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserASSIGN, i)
}

func (s *StructConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *StructConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StructConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStructConstructor(s)
	}
}

func (s *StructConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStructConstructor(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type QualifiedColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewQualifiedColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedColumnReferenceContext {
	var p = new(QualifiedColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *QualifiedColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedColumnReferenceContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedColumnReferenceContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQualifiedColumnReference(s)
	}
}

func (s *QualifiedColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQualifiedColumnReference(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(KSqlParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CastContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type MapConstructorContext struct {
	*PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *MapConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *MapConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserASSIGN)
}

func (s *MapConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserASSIGN, i)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *FunctionCallContext) AllFunctionArgument() []IFunctionArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionArgumentContext)(nil)).Elem())
	var tst = make([]IFunctionArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionArgumentContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionCallContext) AllLambdaFunction() []ILambdaFunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILambdaFunctionContext)(nil)).Elem())
	var tst = make([]ILambdaFunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILambdaFunctionContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) LambdaFunction(i int) ILambdaFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaFunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(KSqlParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type LiteralExpressionContext struct {
	*PrimaryExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (p *KSqlParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *KSqlParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, KSqlParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(857)
			p.Literal()
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(858)
			p.Identifier()
		}
		{
			p.SetState(859)
			p.Match(KSqlParserSTRING)
		}

	case 3:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(861)
			p.Match(KSqlParserCASE)
		}
		{
			p.SetState(862)
			p.valueExpression(0)
		}
		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KSqlParserWHEN {
			{
				p.SetState(863)
				p.WhenClause()
			}

			p.SetState(866)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserELSE {
			{
				p.SetState(868)
				p.Match(KSqlParserELSE)
			}
			{
				p.SetState(869)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(872)
			p.Match(KSqlParserEND)
		}

	case 4:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(874)
			p.Match(KSqlParserCASE)
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KSqlParserWHEN {
			{
				p.SetState(875)
				p.WhenClause()
			}

			p.SetState(878)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserELSE {
			{
				p.SetState(880)
				p.Match(KSqlParserELSE)
			}
			{
				p.SetState(881)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(884)
			p.Match(KSqlParserEND)
		}

	case 5:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(886)
			p.Match(KSqlParserCAST)
		}
		{
			p.SetState(887)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(888)
			p.Expression()
		}
		{
			p.SetState(889)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(890)
			p.sqltype(0)
		}
		{
			p.SetState(891)
			p.Match(KSqlParserT__3)
		}

	case 6:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(893)
			p.Match(KSqlParserARRAY)
		}
		{
			p.SetState(894)
			p.Match(KSqlParserT__5)
		}
		p.SetState(903)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserNOT-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(895)
				p.Expression()
			}
			p.SetState(900)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(896)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(897)
					p.Expression()
				}

				p.SetState(902)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(905)
			p.Match(KSqlParserT__6)
		}

	case 7:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(906)
			p.Match(KSqlParserMAP)
		}
		{
			p.SetState(907)
			p.Match(KSqlParserT__2)
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserNOT-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(908)
				p.Expression()
			}
			{
				p.SetState(909)
				p.Match(KSqlParserASSIGN)
			}
			{
				p.SetState(910)
				p.Expression()
			}
			p.SetState(918)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(911)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(912)
					p.Expression()
				}
				{
					p.SetState(913)
					p.Match(KSqlParserASSIGN)
				}
				{
					p.SetState(914)
					p.Expression()
				}

				p.SetState(920)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(923)
			p.Match(KSqlParserT__3)
		}

	case 8:
		localctx = NewStructConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(924)
			p.Match(KSqlParserSTRUCT)
		}
		{
			p.SetState(925)
			p.Match(KSqlParserT__2)
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(926)
				p.Identifier()
			}
			{
				p.SetState(927)
				p.Match(KSqlParserASSIGN)
			}
			{
				p.SetState(928)
				p.Expression()
			}
			p.SetState(936)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(929)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(930)
					p.Identifier()
				}
				{
					p.SetState(931)
					p.Match(KSqlParserASSIGN)
				}
				{
					p.SetState(932)
					p.Expression()
				}

				p.SetState(938)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(941)
			p.Match(KSqlParserT__3)
		}

	case 9:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(942)
			p.Identifier()
		}
		{
			p.SetState(943)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(944)
			p.Match(KSqlParserASTERISK)
		}
		{
			p.SetState(945)
			p.Match(KSqlParserT__3)
		}

	case 10:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(947)
			p.Identifier()
		}
		{
			p.SetState(948)
			p.Match(KSqlParserT__2)
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserNOT-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserMILLISECOND-35))|(1<<(KSqlParserDAYS-35))|(1<<(KSqlParserHOURS-35))|(1<<(KSqlParserMINUTES-35))|(1<<(KSqlParserSECONDS-35))|(1<<(KSqlParserMILLISECONDS-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(949)
				p.FunctionArgument()
			}
			p.SetState(954)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(950)
						p.Match(KSqlParserT__1)
					}
					{
						p.SetState(951)
						p.FunctionArgument()
					}

				}
				p.SetState(956)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())
			}
			p.SetState(961)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(957)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(958)
					p.LambdaFunction()
				}

				p.SetState(963)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(966)
			p.Match(KSqlParserT__3)
		}

	case 11:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(968)
			p.Identifier()
		}

	case 12:
		localctx = NewQualifiedColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(969)
			p.Identifier()
		}
		{
			p.SetState(970)
			p.Match(KSqlParserT__4)
		}
		{
			p.SetState(971)
			p.Identifier()
		}

	case 13:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(973)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(974)
			p.Expression()
		}
		{
			p.SetState(975)
			p.Match(KSqlParserT__3)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(987)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_primaryExpression)
				p.SetState(979)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(980)
					p.Match(KSqlParserT__5)
				}
				{
					p.SetState(981)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(982)
					p.Match(KSqlParserT__6)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_primaryExpression)
				p.SetState(984)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(985)
					p.Match(KSqlParserSTRUCT_FIELD_REF)
				}
				{
					p.SetState(986)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
	}

	return localctx
}

// IFunctionArgumentContext is an interface to support dynamic dispatch.
type IFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionArgumentContext differentiates from other interfaces.
	IsFunctionArgumentContext()
}

type FunctionArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentContext() *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_functionArgument
	return p
}

func (*FunctionArgumentContext) IsFunctionArgumentContext() {}

func NewFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_functionArgument

	return p
}

func (s *FunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgumentContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *FunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFunctionArgument(s)
	}
}

func (s *FunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFunctionArgument(s)
	}
}

func (p *KSqlParser) FunctionArgument() (localctx IFunctionArgumentContext) {
	localctx = NewFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KSqlParserRULE_functionArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(992)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(993)
			p.WindowUnit()
		}

	}

	return localctx
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_timeZoneSpecifier
	return p
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyFrom(ctx *TimeZoneSpecifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneStringContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(KSqlParserZONE, 0)
}

func (s *TimeZoneStringContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *KSqlParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KSqlParserRULE_timeZoneSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTimeZoneStringContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		p.Match(KSqlParserTIME)
	}
	{
		p.SetState(997)
		p.Match(KSqlParserZONE)
	}
	{
		p.SetState(998)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(KSqlParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *KSqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KSqlParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1000)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-144)&-(0x1f+1)) == 0 && ((1<<uint((_la-144)))&((1<<(KSqlParserEQ-144))|(1<<(KSqlParserNEQ-144))|(1<<(KSqlParserLT-144))|(1<<(KSqlParserLTE-144))|(1<<(KSqlParserGT-144))|(1<<(KSqlParserGTE-144)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *KSqlParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KSqlParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserTRUE || _la == KSqlParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISqltypeContext is an interface to support dynamic dispatch.
type ISqltypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqltypeContext differentiates from other interfaces.
	IsSqltypeContext()
}

type SqltypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqltypeContext() *SqltypeContext {
	var p = new(SqltypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sqltype
	return p
}

func (*SqltypeContext) IsSqltypeContext() {}

func NewSqltypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqltypeContext {
	var p = new(SqltypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sqltype

	return p
}

func (s *SqltypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SqltypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *SqltypeContext) AllSqltype() []ISqltypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISqltypeContext)(nil)).Elem())
	var tst = make([]ISqltypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISqltypeContext)
		}
	}

	return tst
}

func (s *SqltypeContext) Sqltype(i int) ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *SqltypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *SqltypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *SqltypeContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *SqltypeContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SqltypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserDECIMAL, 0)
}

func (s *SqltypeContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *SqltypeContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SqltypeContext) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *SqltypeContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *SqltypeContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *SqltypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqltypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqltypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSqltype(s)
	}
}

func (s *SqltypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSqltype(s)
	}
}

func (p *KSqlParser) Sqltype() (localctx ISqltypeContext) {
	return p.sqltype(0)
}

func (p *KSqlParser) sqltype(_p int) (localctx ISqltypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSqltypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISqltypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 96
	p.EnterRecursionRule(localctx, 96, KSqlParserRULE_sqltype, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1005)
			p.Match(KSqlParserARRAY)
		}
		{
			p.SetState(1006)
			p.Match(KSqlParserLT)
		}
		{
			p.SetState(1007)
			p.sqltype(0)
		}
		{
			p.SetState(1008)
			p.Match(KSqlParserGT)
		}

	case 2:
		{
			p.SetState(1010)
			p.Match(KSqlParserMAP)
		}
		{
			p.SetState(1011)
			p.Match(KSqlParserLT)
		}
		{
			p.SetState(1012)
			p.sqltype(0)
		}
		{
			p.SetState(1013)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(1014)
			p.sqltype(0)
		}
		{
			p.SetState(1015)
			p.Match(KSqlParserGT)
		}

	case 3:
		{
			p.SetState(1017)
			p.Match(KSqlParserSTRUCT)
		}
		{
			p.SetState(1018)
			p.Match(KSqlParserLT)
		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(1019)
				p.Identifier()
			}
			{
				p.SetState(1020)
				p.sqltype(0)
			}
			p.SetState(1027)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(1021)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(1022)
					p.Identifier()
				}
				{
					p.SetState(1023)
					p.sqltype(0)
				}

				p.SetState(1029)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1032)
			p.Match(KSqlParserGT)
		}

	case 4:
		{
			p.SetState(1033)
			p.Match(KSqlParserDECIMAL)
		}
		{
			p.SetState(1034)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(1035)
			p.Number()
		}
		{
			p.SetState(1036)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(1037)
			p.Number()
		}
		{
			p.SetState(1038)
			p.Match(KSqlParserT__3)
		}

	case 5:
		{
			p.SetState(1040)
			p.BaseType()
		}
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1041)
				p.Match(KSqlParserT__2)
			}
			{
				p.SetState(1042)
				p.TypeParameter()
			}
			p.SetState(1047)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(1043)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(1044)
					p.TypeParameter()
				}

				p.SetState(1049)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1050)
				p.Match(KSqlParserT__3)
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1060)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSqltypeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_sqltype)
			p.SetState(1056)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
			}
			{
				p.SetState(1057)
				p.Match(KSqlParserARRAY)
			}

		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *KSqlParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KSqlParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserT__7 || _la == KSqlParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *KSqlParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KSqlParserRULE_baseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		p.Identifier()
	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *KSqlParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KSqlParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(KSqlParserWHEN)
	}
	{
		p.SetState(1068)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1069)
		p.Match(KSqlParserTHEN)
	}
	{
		p.SetState(1070)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type VariableIdentifierContext struct {
	*IdentifierContext
}

func NewVariableIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableIdentifierContext {
	var p = new(VariableIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *VariableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableIdentifierContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLE, 0)
}

func (s *VariableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableIdentifier(s)
	}
}

func (s *VariableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableIdentifier(s)
	}
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type QuotedIdentifierAlternativeContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonReservedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *KSqlParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KSqlParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1078)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserVARIABLE:
		localctx = NewVariableIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1072)
			p.Match(KSqlParserVARIABLE)
		}

	case KSqlParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1073)
			p.Match(KSqlParserIDENTIFIER)
		}

	case KSqlParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1074)
			p.Match(KSqlParserQUOTED_IDENTIFIER)
		}

	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1075)
			p.NonReserved()
		}

	case KSqlParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1076)
			p.Match(KSqlParserBACKQUOTED_IDENTIFIER)
		}

	case KSqlParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1077)
			p.Match(KSqlParserDIGIT_IDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILambdaFunctionContext is an interface to support dynamic dispatch.
type ILambdaFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionContext differentiates from other interfaces.
	IsLambdaFunctionContext()
}

type LambdaFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionContext() *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_lambdaFunction
	return p
}

func (*LambdaFunctionContext) IsLambdaFunctionContext() {}

func NewLambdaFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_lambdaFunction

	return p
}

func (s *LambdaFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionContext) CopyFrom(ctx *LambdaFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LambdaFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LambdaContext struct {
	*LambdaFunctionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.LambdaFunctionContext = NewEmptyLambdaFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LambdaFunctionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (p *KSqlParser) LambdaFunction() (localctx ILambdaFunctionContext) {
	localctx = NewLambdaFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KSqlParserRULE_lambdaFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1097)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1080)
			p.Identifier()
		}
		{
			p.SetState(1081)
			p.Match(KSqlParserLAMBDA_EXPRESSION)
		}
		{
			p.SetState(1082)
			p.Expression()
		}

	case KSqlParserT__2:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1084)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(1085)
			p.Identifier()
		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(1086)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(1087)
				p.Identifier()
			}

			p.SetState(1092)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1093)
			p.Match(KSqlParserT__3)
		}
		{
			p.SetState(1094)
			p.Match(KSqlParserLAMBDA_EXPRESSION)
		}
		{
			p.SetState(1095)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_variableName
	return p
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableName(s)
	}
}

func (s *VariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableName(s)
	}
}

func (p *KSqlParser) VariableName() (localctx IVariableNameContext) {
	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KSqlParserRULE_variableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(KSqlParserIDENTIFIER)
	}

	return localctx
}

// IVariableValueContext is an interface to support dynamic dispatch.
type IVariableValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableValueContext differentiates from other interfaces.
	IsVariableValueContext()
}

type VariableValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableValueContext() *VariableValueContext {
	var p = new(VariableValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_variableValue
	return p
}

func (*VariableValueContext) IsVariableValueContext() {}

func NewVariableValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableValueContext {
	var p = new(VariableValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_variableValue

	return p
}

func (s *VariableValueContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *VariableValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableValue(s)
	}
}

func (s *VariableValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableValue(s)
	}
}

func (p *KSqlParser) VariableValue() (localctx IVariableValueContext) {
	localctx = NewVariableValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KSqlParserRULE_variableValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// ISourceNameContext is an interface to support dynamic dispatch.
type ISourceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceNameContext differentiates from other interfaces.
	IsSourceNameContext()
}

type SourceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceNameContext() *SourceNameContext {
	var p = new(SourceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sourceName
	return p
}

func (*SourceNameContext) IsSourceNameContext() {}

func NewSourceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceNameContext {
	var p = new(SourceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sourceName

	return p
}

func (s *SourceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SourceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSourceName(s)
	}
}

func (s *SourceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSourceName(s)
	}
}

func (p *KSqlParser) SourceName() (localctx ISourceNameContext) {
	localctx = NewSourceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KSqlParserRULE_sourceName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		p.Identifier()
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyFrom(ctx *NumberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	*NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type FloatLiteralContext struct {
	*NumberContext
}

func NewFloatLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) FLOATING_POINT_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserFLOATING_POINT_VALUE, 0)
}

func (s *FloatLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

type IntegerLiteralContext struct {
	*NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *KSqlParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KSqlParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1105)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1108)
			p.Match(KSqlParserDECIMAL_VALUE)
		}

	case 2:
		localctx = NewFloatLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1109)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1112)
			p.Match(KSqlParserFLOATING_POINT_VALUE)
		}

	case 3:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1113)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1116)
			p.Match(KSqlParserINTEGER_VALUE)
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NullLiteralContext struct {
	*LiteralContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	*LiteralContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type VariableLiteralContext struct {
	*LiteralContext
}

func NewVariableLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableLiteralContext {
	var p = new(VariableLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *VariableLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableLiteralContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLE, 0)
}

func (s *VariableLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableLiteral(s)
	}
}

func (s *VariableLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableLiteral(s)
	}
}

type NumericLiteralContext struct {
	*LiteralContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	*LiteralContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *KSqlParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KSqlParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1124)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1119)
			p.Match(KSqlParserNULL)
		}

	case KSqlParserMINUS, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1120)
			p.Number()
		}

	case KSqlParserTRUE, KSqlParserFALSE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1121)
			p.BooleanValue()
		}

	case KSqlParserSTRING:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1122)
			p.Match(KSqlParserSTRING)
		}

	case KSqlParserVARIABLE:
		localctx = NewVariableLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1123)
			p.Match(KSqlParserVARIABLE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLES, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMNS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMN, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITIONS, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTIONS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTION, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(KSqlParserSESSION, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITION, 0)
}

func (s *NonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDATE, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIMESTAMP, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTERVAL, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(KSqlParserZONE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(KSqlParserYEAR, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(KSqlParserMONTH, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAY, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOUR, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTE, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECOND, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXPLAIN, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserANALYZE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPES, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(KSqlParserSET, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(KSqlParserRESET, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *NonReservedContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *NonReservedContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *NonReservedContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRIMARY, 0)
}

func (s *NonReservedContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *NonReservedContext) EMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserEMIT, 0)
}

func (s *NonReservedContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(KSqlParserCHANGES, 0)
}

func (s *NonReservedContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFINAL, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserESCAPE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *NonReservedContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *NonReservedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserALTER, 0)
}

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(KSqlParserADD, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *KSqlParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KSqlParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1126)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || _la == KSqlParserALTER || _la == KSqlParserIF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *KSqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 39:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 42:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 43:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 48:
		var t *SqltypeContext = nil
		if localctx != nil {
			t = localctx.(*SqltypeContext)
		}
		return p.Sqltype_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *KSqlParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) Sqltype_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
